
-- Given a base object, computes the 4 bounds points, returned in a table,
-- each with a vector xyz of world pos coords
--
--                       FRONT
--
--        topleft         rotation      topright
--   L       +-------------^--------------+            R
--   E       |             |              |            I
--   F       |             * center       |  z axis    G
--   T       |                            |            H
--           +----------------------------+            T
--         botleft      x axis          botright
--
--                        BACK
function compute_corners_base(base_obj)
    local rotation = normalize_angle(from_degrees_to_rad(base_obj.getRotation())['y'])
    -- print_debug(base_obj.getName() .. ' rotation is ' .. rotation)
    local size = get_size(base_obj.getName())
    local pos = base_obj.getPosition()
    -- print_debug(base_obj.getName() .. ' pos is ' .. vec_to_str(vec_in_to_mm(pos)))
    return compute_corners_coords(size, rotation, pos)
end

-- Like compute_corners_base but instead of a base obj all coords are given
function compute_corners_coords(sizeXZ, rotationY, pos)
    local xhalf = sizeXZ['x'] / 2
    local zhalf = sizeXZ['z'] / 2

    return {
        topright = rotate_point_relative({x = xhalf, y = 0, z = zhalf}, pos, rotationY),
        botright = rotate_point_relative({x = xhalf, y = 0, z =-zhalf}, pos, rotationY),
        topleft  = rotate_point_relative({x =-xhalf, y = 0, z = zhalf}, pos, rotationY),
        botleft  = rotate_point_relative({x =-xhalf, y = 0, z =-zhalf}, pos, rotationY)
    }
end

-- Aligns base2 to a base1, where base1 is an object that will be (but may not
-- be there until next frame) with center position, corners and rotation.
-- Base2 is to the right of Base1 in the x axis
-- Returns a transform table with the new pos, corners and rot
function align_two_bases(base2, position, corners, rotation)
    base2.setRotation(rotation)
    local corners2 = compute_corners_base(base2)

    local angle = normalize_angle(math.rad(rotation['y']))
    local relative_angle = relative_angle_from_point(position, base2.getPosition(), angle)

    local translation = nil
    -- Note that since we know that base1 is to the left of base2, the angle
    -- is 0-90 or 270-360
    if relative_angle > g_alignment_angle_side
       and relative_angle < math.pi then
        -- Angle the back of base2 with the front of base1
        translation = vec_sub(corners['topright'], corners2['botright'])
    elseif relative_angle <= g_alignment_angle_side
           or relative_angle >= (2*math.pi - g_alignment_angle_side) then
        -- Angle the left side of base2 with the right of base1
        translation = vec_sub(corners['topright'], corners2['topleft'])
    else
        -- Angle the front of base2 with the back of base1
        translation = vec_sub(corners['botleft'], corners2['topleft'])
    end

    local new_pos = vec_add(base2.getPosition(), translation)
    base2.setPosition(new_pos)

    return {
        position = new_pos,
        corners = compute_corners_coords(get_size(base2.getName()),angle, new_pos),
        rotation = rotation
    }
end

-- Is the base an object
function is_base_obj(obj)
  local name = obj.getName()
  return  g_bases[name] ~= nil or str_starts_with(obj.getName(), 'base')
end

-- Given a list of objects in a table, returns another table with ONLY
-- those who start with 'base', ignoring the keys
function filter_bases(list)
    local filtered = {}
    for _,obj in ipairs(list) do
        local name = obj.getName()
        if is_base_obj(obj) then
            table.insert(filtered, obj)
        end
    end
    return filtered
end

-- This is like filter_bases, but instead of a plain array, returns a list
-- of GUID to base. This useful for when using a big list which will be operated
-- and searched upon
function get_bases_with_guid(list)
    local filtered = {}
    for _,obj in ipairs(list) do
        local name = obj.getName()
        if g_bases[name] ~= nil or str_starts_with(obj.getName(), 'base') then
            filtered[obj.getGUID()] = obj
        end
    end
    return filtered
end

-- 180ยบ rotation a base
function turn_around_base(obj)
    local initial_transform = calculate_transform(obj)
    local rotation = obj.getRotation()
    rotation['y'] = rotation['y'] + 180
    obj.setRotation(rotation)

    local new_transform = calculate_transform(obj)
    local move = {}
    add_transform_to_move(move, obj.getName(), initial_transform, new_transform)
    push_to_history_stack(move)

    local distance = max_distance_between_bases_front_corners(initial_transform['corners'], new_transform['corners'])
    print_info(obj.getName() .. ' has turned around 180ยบ, which costs '
        .. string.format('%.2f', from_in_to_bw(distance)) .. ' BW')
end

-- Moves one or more DBA bases g_bw_movement forward
-- ASSUMES all bases are in a flat board!!!!
-- Returns how much it moved (it cna move less in a collision)
function move_base(obj, how_much_movement, ignore_history)
    local initial_transform = calculate_transform(obj)
    local current_rotation = from_degrees_to_rad(obj.getRotation())
    local displacement_vector = rad_to_vector(current_rotation['y'])
    local magnitude = how_much_movement
    local destination = vec_add(initial_transform['position'], vec_mul_escalar(displacement_vector, magnitude))

    obj.setPosition(destination)

    if not ignore_history then
        local new_transform = calculate_transform(obj)
        local move = {}
        add_transform_to_move(move, obj.getName(), initial_transform, new_transform)
        push_to_history_stack(move)
    end
    return how_much_movement
end

-- Moves ONE single DBA base by it's depth
function push_back(obj)
    local initial_transform = calculate_transform(obj)
    local angle = from_degrees_to_rad(obj.getRotation())['y']
    angle = angle + math.pi
    if angle > 2*math.pi then
        angle = angle - 2*math.pi
    end
    local displacement_vector = rad_to_vector(angle)

    local magnitude = get_size(obj.getName())['z']
    local destination = vec_add(initial_transform['position'], vec_mul_escalar(displacement_vector, magnitude))
    obj.setPosition(destination)

    local new_transform = calculate_transform(obj)
    local move = {}
    add_transform_to_move(move, obj.getName(), initial_transform, new_transform)
    push_to_history_stack(move)

    local distance = max_distance_between_bases_front_corners(initial_transform['corners'], new_transform['corners'])
    print_info(obj.getName() .. ' has moved backwards its own depth, '
        .. string.format('%.2f', from_in_to_bw(distance)) .. ' BW')
end

-- Like push back but in the other direction
function push_forward(obj)
    local initial_transform = calculate_transform(obj)
    local angle = from_degrees_to_rad(obj.getRotation())['y']
    local displacement_vector = rad_to_vector(angle)

    local magnitude = get_size(obj.getName())['z']
    local destination = vec_add(initial_transform['position'], vec_mul_escalar(displacement_vector, magnitude))
    obj.setPosition(destination)

    local new_transform = calculate_transform(obj)

    local move = {}
    add_transform_to_move(move, obj.getName(), initial_transform, new_transform)
    push_to_history_stack(move)

    local distance = max_distance_between_bases_front_corners(initial_transform['corners'], new_transform['corners'])
    print_info(obj.getName() .. ' has moved forward its own depth, '
        .. string.format('%.2f', from_in_to_bw(distance)) .. ' BW')
end


-- Given a bunch of objects returns them in a column, which is
-- {"front_of"=x, "behind_of" = x, "front_element"=x}, each a mapping
-- of where they are relative to each other.
-- Returns nil if it's not a column.
function calculate_column(objs, transforms)
    print_debug('Trying to detect if the given objects are a proper column')
    local front_of = {}
    local behind_of = {}
    local not_connected = {}
    for _, objA in ipairs(objs) do
        local in_front = nil
        local in_back = nil

        for _, objB in ipairs(objs) do
            local skip = false
            if not_connected[objA] ~= nil and not_connected[objA][objB] == true then
                skip = true
            end

            if objA == objB  then
                skip = true
            end

            if not equals_float(transforms[objA]['rotation'],
                                transforms[objB]['rotation']) then
                print_debug(objA.getName()
                    .. ' doesn\'t have the same rotation ('
                    .. transforms[objA]['rotation'] .. ') '
                    .. 'as ' .. objB.getName() .. ' ('
                    .. transforms[objB]['rotation'] .. ') '
                    .. 'which means this column will not be valid.')
                skip = true
            end

            if not skip then
                if front_of[objA] == objB
                   or is_behind(transforms[objA], transforms[objB]) then
                    in_front = objB
                elseif behind_of[objA] == objB
                       or is_behind(transforms[objB], transforms[objA]) then
                    in_back = objB
                else
                    if not_connected[objA] == nil then
                        not_connected[objA] = {}
                    end
                    not_connected[objA][objB] = true
                end
            end
        end

        if in_front == nil and in_back == nil then
            print_debug(objA.getName() .. ' is isolated and not part of a column')
            return nil
        end

        if in_front ~= nil then
            front_of[objA] = in_front
            behind_of[in_front] = objA
            print_debug(objA.getName() .. ' has ' .. in_front.getName() .. ' in front')
        end
        if in_back ~= nil then
            front_of[in_back] = objA
            behind_of[objA] = in_back
            print_debug(objA.getName() .. ' has ' .. in_back.getName() .. ' behind')
        end
    end

    local front_element = nil
    for _, obj in ipairs(objs) do
        if front_of[obj] == nil then
            front_element = obj
            break
        end
    end

    if front_element == nil then
        print_debug('There\'s no front element in this column')
        return nil
    end

    return {
        front_of = front_of,
        behind_of = behind_of,
        front_element = front_element
    }
end

-- Like calculate column, but for a group. Returns
-- {"front_of" = {x=y, y=z...},
--  "behind_of" = {x=y, y=z...},
--  "front_elements"={x,y,z..},
--  "leftmost" = x,
--  "rightmost" = x
--  "depth" = x}
-- Each front_element correspond with the front of a column.
-- All front elements are left_of or right of someone else
function calculate_group(objs, transforms)
    local front_of = {}
    local behind_of = {}
    local not_connected = {}
    for _, objA in ipairs(objs) do
        local in_front = nil
        local in_back = nil

        for _, objB in ipairs(objs) do
            local skip = false
            if not_connected[objA] ~= nil and not_connected[objA][objB] == true then
                skip = true
            end

            if objA == objB  then
                skip = true
            end

            if not skip then
                if front_of[objA] == objB
                   or is_behind(transforms[objA], transforms[objB]) then
                    in_front = objB
                elseif behind_of[objA] == objB
                       or is_behind(transforms[objB], transforms[objA]) then
                    in_back = objB
                else
                    if not_connected[objA] == nil then
                        not_connected[objA] = {}
                    end
                    not_connected[objA][objB] = true
                end
            end
        end

        if in_front ~= nil then
            front_of[objA] = in_front
            behind_of[in_front] = objA
        end
        if in_back ~= nil then
            front_of[in_back] = objA
            behind_of[objA] = in_back
        end
    end

    local col_index = 0
    local cols = {}
    for _, obj in ipairs(objs) do
        if front_of[obj] ~= nil then
            if cols[front_of[obj]] ~= nil then
                -- This belongs to the same column
                cols[obj] = cols[front_of[obj]]
            else
                -- Neither belong to a column yet, add it
                cols[obj] = col_index
                col_index = col_index + 1
            end
        elseif behind_of[obj] ~= nil then
            if cols[behind_of[obj]] ~= nil then
                -- This belongs to the same column
                cols[obj] = cols[behind_of[obj]]
            else
                -- Neither belong to a column yet, add it
                cols[obj] = col_index
                col_index = col_index + 1
            end
        else
            -- Column of one element
            cols[obj] = col_index
            col_index = col_index + 1
        end
    end

    local front_elements = {}
    local max_col_depth = 0
    for i = 0, col_index-1 do
        local col_depth = 0
        for obj, col in pairs(cols) do
            if col == i then
                if front_of[obj] == nil then
                    front_elements[col] = obj
                end
                col_depth = col_depth + get_size(obj.getName())['z'];
            end
        end
        if col_depth > max_col_depth then
            max_col_depth = col_depth
        end
    end

    local not_connected = {}
    local left_of = {}
    local right_of = {}
    for _, objA in pairs(front_elements) do
        local in_left = nil
        local in_right = nil

        for _, objB in pairs(front_elements) do
            local skip = false
            if not_connected[objA] ~= nil and not_connected[objA][objB] == true then
                skip = true
            end

            if objA == objB  then
                skip = true
            end

            if not skip then
                if right_of[objA] == objB
                   or is_left_side(transforms[objA], transforms[objB]) then
                    print_debug(objA.getName() .. ' is to the left of ' .. objB.getName())
                    in_right = objB
                elseif left_of[objA] == objB
                       or is_right_side(transforms[objA], transforms[objB]) then
                    print_debug(objA.getName() .. ' is to the right of ' .. objB.getName())
                    in_left = objB
                else
                    print_debug(objA.getName() .. ' is not connected to ' .. objB.getName())
                    if not_connected[objA] == nil then
                        not_connected[objA] = {}
                    end
                    not_connected[objA][objB] = true
                end
            end
        end

        if in_left == nil and in_right == nil then
            -- This shouild only happen if there's only one column
            if col_index > 1 then
                return nil
            end
        end

        if in_left ~= nil then
            left_of[objA] = in_left
            right_of[in_left] = objA
        end
        if in_right ~= nil then
            left_of[in_right] = objA
            right_of[objA] = in_right
        end
    end

    local leftmost = nil
    local rightmost = nil
    for _, obj in pairs(front_elements) do
        if left_of[obj] == nil then
            leftmost = obj
        end
        if right_of[obj] == nil then
            rightmost = obj
        end
    end

    return {
        front_of = front_of,
        behind_of = behind_of,
        front_elements = front_elements,
        leftmost = leftmost,
        rightmost = rightmost,
        depth = max_col_depth
    }
end

-- Pushes back a whole column, that may not be exactly aligned
function push_back_column(objs)
    -- We use many comparisons for the column so we precalculate all the
    -- transforms
    local transforms = {}
    for _, obj in ipairs(objs) do
        transforms[obj] = calculate_transform(obj)
    end

    local column = calculate_column(objs, transforms)
    if column == nil then
        print_warning('Trying to push back but it\'s not a proper column')
        return
    end

    local behind_of = column['behind_of']
    local front_element = column['front_element']

    local base_depth = get_size(front_element.getName())['z']
    local distance = base_depth
    if distance > g_base_width_inches then
        distance = g_base_width_inches
    end

    local angle = from_degrees_to_rad(front_element.getRotation())['y']
    angle = angle + math.pi
    if angle > 2*math.pi then
        angle = angle - 2*math.pi
    end

    local move = {}

    -- Move the front_element fist, then align the others to its back
    local displacement_vector = rad_to_vector(angle)
    local destination = vec_add(front_element.getPosition(), vec_mul_escalar(displacement_vector, distance))
    front_element.setPosition(destination)
    add_transform_to_move(move, front_element.getName(), transforms[front_element], calculate_transform(front_element))

    local magnitude = base_depth / 2
    local next_element = behind_of[front_element]
    while next_element ~= nil do
        next_element.setRotation(front_element.getRotation())

        base_depth = get_size(next_element.getName())['z']
        magnitude = magnitude + base_depth / 2
        local next_destination = vec_add(destination, vec_mul_escalar(displacement_vector, magnitude))
        next_element.setPosition(next_destination)
        add_transform_to_move(move, front_element.getName(), transforms[front_element], calculate_transform(front_element))

        front_element = next_element
        next_element = behind_of[next_element]

        magnitude = magnitude + base_depth / 2
    end
    push_to_history_stack(move)
end

-- Calculates the future position of the given group of objs, assuming a wheel
-- from the position with the given angle and from the relative position
-- (a string which is left or right).
-- The future position will be drawn!
-- Returns the movement cost if possible (>=0), -1 if its impossible (invalid group)
g_current_wheel_group = nil
g_current_wheel_transforms = nil
g_current_wheel_newtransforms = nil
function wheel_group(objs, angle, direction)
    -- HC SVNT DRACONES
    if g_current_wheel_group == nil then
        -- We use many comparisons for the column so we precalculate all the
        -- transforms
        local transforms = {}
        for _, obj in ipairs(objs) do
            transforms[obj] = calculate_transform(obj)
        end

        g_current_wheel_group = calculate_group(objs, transforms)
        if g_current_wheel_group == nil then
            print_warning('Trying to wheel but it\'s not a proper group')
            return -1
        end

        g_current_wheel_transforms = transforms
    end

    local transform_pivot = g_current_wheel_transforms[g_current_wheel_group['leftmost']]
    local pivot_point = transform_pivot['corners']['topleft']
    if direction == 'right' then
        transform_pivot = g_current_wheel_transforms[g_current_wheel_group['rightmost']]
        pivot_point = transform_pivot['corners']['topright']
    end

    local front_elements = g_current_wheel_group['front_elements']
    local furthest_element = nil
    local furthest_element_distance = 0
    for col, front_element in pairs(front_elements) do
        local transform = g_current_wheel_transforms[front_element]
        local distance = distance_points_flat_sq(pivot_point, transform['position'])
        if distance > furthest_element_distance then
            furthest_element_distance = distance
            furthest_element = front_element
        end
    end

    local behind_of = g_current_wheel_group['behind_of']
    local depth = g_current_wheel_group['depth']

    local new_transforms = {}
    for col, front_element in pairs(front_elements) do
        new_transforms[front_element] = calculate_future_position_wheel(
            front_element,
            g_current_wheel_transforms[front_element],
            pivot_point,
            angle,
            direction == 'left',
            depth)
        local current_element = front_element
        while behind_of[current_element] ~= nil do
            current_element = behind_of[current_element]

            new_transforms[current_element] = calculate_future_position_wheel(
                current_element,
                g_current_wheel_transforms[current_element],
                pivot_point,
                angle,
                direction == 'left',
                depth)
        end
    end
    draw_gizmo_wheeling(new_transforms)

    local max_movement_distance = 0
    if direction == 'right' then
        max_movement_distance = distance_points_flat(
            g_current_wheel_transforms[furthest_element]['corners']['topleft'],
            new_transforms[furthest_element]['corners']['topleft'])
    else
        max_movement_distance = distance_points_flat(
            g_current_wheel_transforms[furthest_element]['corners']['topright'],
            new_transforms[furthest_element]['corners']['topright'])
    end
    g_current_wheel_newtransforms = new_transforms
    return from_in_to_bw(max_movement_distance)
end

function apply_transform_obj(base_obj, old_transform, new_transform)
    local distance = max_distance_between_bases_front_corners(old_transform['corners'], new_transform['corners'])
    print_info('Base ' .. base_obj.getName() .. ' is moving '
        .. string.format('%.2f', from_in_to_bw(distance)) .. ' BW')
    base_obj.setPosition(new_transform['position'])
    base_obj.setRotation(transform_to_rotation_vector(new_transform))
end

function perform_wheels()
    local new_transforms = g_current_wheel_newtransforms
    local old_transforms = g_current_wheel_transforms
    local front_elements = g_current_wheel_group['front_elements']
    local behind_of = g_current_wheel_group['behind_of']

    local move = {}
    for col, front_element in pairs(front_elements) do
        local current_element = front_element
        apply_transform_obj(current_element,
            old_transforms[current_element],
            new_transforms[current_element])
        add_transform_to_move(move, current_element.getName(), old_transforms[current_element], new_transforms[current_element])
        while behind_of[current_element] ~= nil do
            current_element = behind_of[current_element]
            apply_transform_obj(current_element,
                old_transforms[current_element],
                new_transforms[current_element])
            add_transform_to_move(move, current_element.getName(), old_transforms[current_element], new_transforms[current_element])
        end
    end
    push_to_history_stack(move)
end

function calculate_future_position_wheel(obj, transform, pivot_point, angle, is_left, depth)
    local new_angle = positive_angle(transform['rotation'] + angle)
    local effective_angle = angle
    if not is_left then
        new_angle = positive_angle(transform['rotation'] - angle)
        effective_angle = -angle
    end

    local new_pos = rotate_point(transform['position'], pivot_point, effective_angle)
    local size = get_size(obj.getName())
    local new_corners = compute_corners_coords(size, new_angle, new_pos)

    return get_transform(new_pos, new_corners, new_angle)
end


function transform_to_shape(transform)
  corners=transform['corners']
  shape={
    corners['topright'], corners['topleft'], corners['botleft'],
    corners['botright']
  }
  return shape
end

-- get a shape that defines a quarter of a base.
-- corners:  transform of the base.
-- quadrant: "topright", "topleft", "botright", or "botleft"
-- return the shape of the quadrant
function base_quadrant_shape(transform, quadrant)
  local corners = transform['corners']
  local mid = mid_point(corners)
  if quadrant == "topleft" then
    local topmid = mid_point(corners['topleft'], corners['topright'])
    local midleft = mid_point(corners['topleft'], corners['botleft'])
    return { corners['topleft'], topmid, mid, midleft }
  end
  if quadrant == "topright" then
    local topmid = mid_point(corners['topleft'], corners['topright'])
    local midright = mid_point(corners['topright'], corners['botright'])
    return { corners['topright'], topmid, mid, midright }
  end
  if quadrant == "botleft" then
    local botmid = mid_point(corners['botleft'], corners['botright'])
    local midleft = mid_point(corners['topleft'], corners['botleft'])
    return { corners['botleft'], botmid, mid, midleft }
  end
  -- botright
  local botmid = mid_point(corners['botleft'], corners['botright'])
  local midright = mid_point(corners['topright'], corners['botright'])
  return { corners['botright'], botmid, mid, midright }
end


-- How close are two corners
-- First corner is trasformA[cornerALabel]
-- Second corner is transformB[cornerBLabel]
-- return is the square of the distance
function corner_snapping_distance(transformA, transformB, cornerALabel,cornerBLabel)
  local cornersA = transformA['corners']
  local cornersB = transformB['corners']
  local pointA = cornersA [ cornerALabel ]
  local pointB = cornersB [ cornerBLabel ]
  local distance_sq = distance_points_flat_sq(pointA, pointB)
  return distance_sq
end

-- How close are the set of corners that should be together.
-- Return the maximum (distance^2) between the pairs.
function corners_snapping_distance(transformA, transformB, matching_corners)
  local result = 0
  for _,pair in ipairs(matching_corners) do
    local d2 = corner_snapping_distance(transformA, transformB, pair[1], pair[2])
    result = math.max(result, d2)
  end
  return result
end

-- Are two edges considered to be touching each other.
-- Distance between the corners squared.
function is_corners_adjacent(distance_sq)
  return distance_sq < g_max_corner_distance_snap
end

-- Checks if the object A defined by its transform is inmediately behind
-- object B, which is also represented by its transform
-- returns the maximum (distance^2) for the corners aligning
--
--    +---------+
--    | TL   TR |
--    |    ^    |
--    |    B    |
--    | BL   BR |
--    +---------+
--    | TL   TR |
--    |    ^    |
--    |    A    |
--    | BL   BR |
--    +---------+
--
function distance_front_to_back(transformA, transformB)
    local angleA = transformA['rotation']
    local angleB = transformB['rotation']
    if not is_rad_angle_diff(angleA, angleB, 0) then
       -- Angle is too different, skip
       return math.huge
    end

    local matching_corners = {
        {'topright', 'botright'},
        {'topleft', 'botleft'}
    }

    return corners_snapping_distance(transformA, transformB, matching_corners)
end


function is_behind(transformA, transformB)
  return is_corners_adjacent(distance_front_to_back(transformA, transformB))
end

-- Determines if A is to the left of B
-- returns the maximum (distance^2) for the corners aligning
--
--   +----------+---------+
--   | TL    TR | TL   TR |
--   |    ^     |    ^    |
--   |    A     |    B    |
--   | BL    BR | BL   BR |
--   +----------+---------+
--
function distance_right_to_left_side(transformA, transformB)
    local angleA = transformA['rotation']
    local angleB = transformB['rotation']
    if not is_rad_angle_diff(angleA, angleB, 0) then
       -- Angle is too different, skip
       return math.huge
    end

    local matching_corners = {
        {'topright', 'topleft'}
    }
    -- Note: We do not check the bottom because bases may be of different
    -- sizes and we already check the angle

    return corners_snapping_distance(transformA, transformB, matching_corners)
end

function is_left_side(transformA, transformB)
  return is_corners_adjacent(distance_right_to_left_side(transformA, transformB))
end

-- Determines if A is to the right of B
-- returns the maximum (distance^2) for the corners aligning
--
--   +----------+---------+
--   | TL    TR | TL   TR |
--   |    ^     |    ^    |
--   |    B     |    A    |
--   | BL    BR | BL   BR |
--   +----------+---------+
--
function distance_left_to_right_side(transformA, transformB)
  return distance_right_to_left_side(transformB, transformA)
end

function is_right_side(transformA, transformB)
  return is_corners_adjacent(distance_left_to_right_side(transformA, transformB))
end

-- Determines if A is in front of B
-- returns the maximum (distance^2) for the corners aligning
--
--    +---------+
--    | TL   TR |
--    |    ^    |
--    |    A    |
--    | BL   BR |
--    +---------+
--    | TL   TR |
--    |    ^    |
--    |    B    |
--    | BL   BR |
--    +---------+
--
function distance_back_to_front(transformA, transformB)
  return distance_front_to_back(transformB, transformA)
end

function is_infront(transformA, transformB)
  return is_corners_adjacent(distance_back_to_front(transformA, transformB))
end


--     +-------------+
--     | TL   ^   TR |
--     |      B      |
--     | BL       BR |
--     +-------------+------+
--     | TR              BR |
--     |      <  A          |
--     | TL              BL |
--     +--------------------+
function distance_right_to_back(transformA, transformB)
    local angleA = transformA['rotation']
    local angleB = transformB['rotation']

    if not is_rad_angle_diff(angleA, angleB, math.pi/2) then
       -- Angle is too different, skip
       return math.huge
    end

    local matching_corners = {
        {'topright', 'botleft'}
    }
    -- Note: We do not check the bottom because bases may be of different
    -- sizes and we already check the angle

    return corners_snapping_distance(transformA, transformB, matching_corners)
end

--   +------------------+
--   | BL           TL  |
--   |          A  >    |
--   | BL           TR  |
--   +----+-------------+
--        | TL   ^   TR |
--        |      B      |
--        | BL       BR |
--        +-------------+-
function distance_right_to_front(transformA, transformB)
    local angleA = transformA['rotation']
    local angleB = transformB['rotation']
    local diff_angle = math.abs(angleB - angleA)

    -- Around 90 or 270 degrees
    if math.abs(math.pi/2 - diff_angle) > g_max_angle_pushback_rad and
       math.abs(3*math.pi/2 - diff_angle) > g_max_angle_pushback_rad then
       -- Angle is too different, skip
       return math.huge
    end

    local matching_corners = {
        {'topright', 'topright'}
    }
    -- Note: We do not check the bottom because bases may be of different
    -- sizes and we already check the angle

    return corners_snapping_distance(transformA, transformB, matching_corners)
end

--         +------------+
--         | TL      TR |
--         |      ^     |
--         |      B     |
--         | BL      BR |
--    +----+------------+
--    | BL           TL |
--    |      A  >       |
--    | BR           TR |
--    +-----------------+
function distance_left_to_back(transformA, transformB)
    local angleA = transformA['rotation']
    local angleB = transformB['rotation']
    if not is_rad_angle_diff(angleA, angleB, 1.5*math.pi) then
       -- Angle is too different, skip
       return math.huge
    end

   local matching_corners = {
        {'topleft', 'botright'}
    }
    -- Note: We do not check the bottom because bases may be of different
    -- sizes and we already check the angle

    return corners_snapping_distance(transformA, transformB, matching_corners)
end


function distance_back_to_left(transformA, transformB)
  return distance_left_to_back(transformB, transformA)
end



--    +------------------+
--    | TR            BR |
--    |      < A         |
--    | TL            BL |
--    +------------+-----+
--    | TL      TR |
--    |      ^     |
--    |      B     |
--    | BL      BR |
--    +------------+
function distance_left_to_front(transformA, transformB)
   local angleA = transformA['rotation']
    local angleB = transformB['rotation']
    local diff_angle = math.abs(angleB - angleA)

    -- Around 90 or 270 degrees
    if math.abs(math.pi/2 - diff_angle) > g_max_angle_pushback_rad and
       math.abs(3*math.pi/2 - diff_angle) > g_max_angle_pushback_rad then
       -- Angle is too different, skip
       return math.huge
    end

   local matching_corners = {
        {'topleft', 'topleft'}
    }
    -- Note: We do not check the bottom because bases may be of different
    -- sizes and we already check the angle

    return corners_snapping_distance(transformA, transformB, matching_corners)
 end



function distance_back_to_left(transformA, transformB)
  return distance_left_to_back(transformB, transformA)
 end


-- Determines if A is in front B, looking at B, while B looks at A
-- returns the maximum (distance^2) for the corners aligning
--
-- +--------+
-- | BR  BL |
-- |        |
-- |    V   |
-- | TR  TL |
-- +--------+
-- | TL  TR |
-- |    ^   |
-- | BL  BR |
-- +--------+
--
function distance_front_to_front(transformA, transformB)
    local angleA = transformA['rotation']
    local angleB = transformB['rotation']
    local diff_angle = math.abs(angleB - angleA)
    local angle_180 = math.abs(math.pi - diff_angle)

    if angle_180 >= g_max_angle_pushback_rad then
       -- Angle is too different, skip
       return math.huge
    end

   local matching_corners = {
        {'topright', 'topleft'},
        {'topleft', 'topright'}
    }
    return corners_snapping_distance(transformA, transformB, matching_corners)
end

-- Determines if A is in the of side of B, "closing its door", which in DBA
-- terms means that the left corner of A is touching the left corner B, and A
-- is looking at B, while B does NOT look at A.
--
-- +----------+------------+
-- | BL    TL | TL      TR |
-- |    A>    |      ^     |
-- | BR    TR |      B     |
-- +----------+ BL      BR |
--            +------------+
--
-- returns the maximum (distance^2) for the corners aligning
function distance_front_to_left(transformA, transformB)
    local angleA = transformA['rotation']
    local angleB = transformB['rotation']
    local diff_angle = angleB - angleA
    if diff_angle < 0 then
        diff_angle = diff_angle + 2*math.pi
    end
    local angle_90 = math.abs(math.pi/2 - diff_angle)
    if angle_90 >= g_max_angle_pushback_rad then
      return math.huge
    end

   local matching_corners = {
        {'topleft', 'topleft'},
    }
    return corners_snapping_distance(transformA, transformB, matching_corners)
end

-- returns the maximum (distance^2) for the corners aligning
--
-- +----------+----------------+
-- | TL    TR | TR          BR |
-- |     ^    |   < A          |
-- |     B    | TL          BL |
-- |          +----------------+
-- |          |
-- |          |
-- | BL    BR |
-- +----------+
--
function distance_front_to_right(transformA, transformB)
    local angleA = transformA['rotation']
    local angleB = transformB['rotation']
    local diff_angle = angleB - angleA
    if diff_angle < 0 then
        diff_angle = diff_angle + 2*math.pi
    end
    local angle_270 = math.abs(3*math.pi/2 - diff_angle)
    if angle_270 >= g_max_angle_pushback_rad then
       -- Angle is too different, skip
       return math.huge
    end

   local matching_corners = {
        {'topright', 'topright'},
    }
    return corners_snapping_distance(transformA, transformB, matching_corners)
end

-- tile_name: string.  e.g. 'tile_plain_WWg_40x80'  Name of the
-- variable that contains the information for a tile.
function get_depth_base(tile_name)
    local base_data = _G[tile_name]
    return from_mm_to_in(base_data['depth'])
end

function get_size(base_name)
  local tile = g_bases[base_name]['tile']
  return {
        x = g_base_width_inches,
        y = g_base_height_inches,
        z = get_depth_base(tile)
    }
end

function is_base_red_player(base_name)
    return g_bases[base_name]['is_red_player']
end

function is_base_blue_player(base_name)
    return not is_base_red_player(base_name)
end

function max_distance_between_bases(base1_corners, base2_corners)
    return compute_max_array({
        distance_points_flat(base1_corners['topright'], base2_corners['topright']),
        distance_points_flat(base1_corners['topleft'], base2_corners['topleft']),
        distance_points_flat(base1_corners['botright'], base2_corners['botright']),
        distance_points_flat(base1_corners['botleft'], base2_corners['botleft'])
    })
end

-- On tactical moves, you only use the front corners to measure, even if the
-- back corner moves more!
function max_distance_between_bases_front_corners(base1_corners, base2_corners)
    return compute_max_array({
        distance_points_flat(base1_corners['topright'], base2_corners['topright']),
        distance_points_flat(base1_corners['topleft'], base2_corners['topleft'])
    })
end

g_picked_base_obj = nil
g_picked_base_initial_transform = nil
function onObjectPickUp(player_color,  picked_up_object)
    if g_bases[picked_up_object.getName()] == nil then
        return
    end

    local objs = filter_bases(Player[player_color].getSelectedObjects())
    local n_objs = tlen(objs)
    if n_objs > 1 then
        -- Ignoring this, we don't want to print the circle for more than one unit
        return
    end

    if g_picked_base_obj ~= nil then
        print_warning("There's already a player picking up an object. Please, wait until he finishes moving.")
        return
    end

    g_picked_base_obj = picked_up_object
    g_picked_base_initial_transform = calculate_transform(picked_up_object)

    draw_all_gizmos()
end

function snap_to_base(obj, transformObj, base, transformBase, direction)
    print_info(obj.getName() .. ' is snapping to ' .. base.getName() .. ', ' .. direction)
    local new_rotation = base.getRotation()
    if direction == 'opposite'
       or direction == 'door_left'
       or direction == 'door_right'
       or direction == 'wwg_left_front'
       or direction == 'wwg_left_to_back'
       or direction == 'wwg_right_front'
       or direction == 'wwg_right_to_back'
       or direction == 'left_to_wwg_front'
       or direction == 'left_to_wwg_back'
       or direction == 'right_to_wwg_front'
       or direction == 'right_to_wwg_back' then
        local new_y = 0
        if direction == 'opposite' then
            new_y = new_rotation['y'] + 180
        elseif direction == 'door_left'
               or direction == 'wwg_left_front'
               or direction == 'left_to_wwg_back'
               or direction == 'wwg_right_front'
               or direction == 'wwg_left_to_back'
               or direction == 'right_to_wwg_front'then
            new_y = new_rotation['y'] + 90
        elseif direction == 'door_right'
          or direction == 'wwg_right_to_back'
               or direction == 'left_to_wwg_front'
               or direction == 'right_to_wwg_back'  then
            new_y = new_rotation['y'] - 90
        end
        if new_y >= 360 then
            new_y = new_y - 360
        elseif new_y < 0 then
            new_y = new_y + 360
        end
        new_rotation['y'] = new_y
    end
    obj.setRotation(new_rotation)

    local sizeObj = get_size(obj.getName())
    local sizeBase = get_size(base.getName())

    local relative_pos = {x = 0, y = 0, z = 0 }

    if direction == 'infront' or direction == 'opposite' then
        relative_pos['z'] = sizeObj['z'] / 2 + sizeBase['z'] / 2
    elseif direction == 'behind' then
        relative_pos['z'] = -1*(sizeObj['z'] / 2 + sizeBase['z'] / 2)
    elseif direction == 'right' then
        -- Since bases maybe of different sizes, we need to align the front
        relative_pos['x'] = sizeObj['x'] / 2 + sizeBase['x'] / 2
        relative_pos['z'] = -1*(sizeObj['z'] - sizeBase['z']) / 2
    elseif direction == 'left' then
        relative_pos['x'] = -1*(sizeObj['x'] / 2 + sizeBase['x'] / 2)
        relative_pos['z'] = -1*(sizeObj['z'] - sizeBase['z']) / 2
    elseif direction == 'wwg_left_to_back' then
      relative_pos['x'] = (sizeObj['x']/-2)
      relative_pos['z'] = (sizeObj['x']  + sizeBase['z'] ) / -2
    elseif direction == 'door_left'
           or direction == 'wwg_left_front' then
        relative_pos['x'] = -1*(sizeObj['z'] / 2 + sizeBase['x'] / 2)
        relative_pos['z'] = -1*(sizeObj['x'] / 2) + (sizeBase['z'] / 2)
    elseif direction == 'door_right' then
        relative_pos['x'] = sizeObj['z'] / 2 + sizeBase['x'] / 2
        relative_pos['z'] = -1*(sizeObj['x'] / 2) + (sizeBase['z'] / 2)
    elseif direction == 'wwg_right_front' then
      relative_pos['x']  =  (-sizeObj['z'] + sizeBase['x'] ) / 2
      relative_pos['z']  = (sizeObj['x'] + sizeBase['z']) / 2
    elseif direction == 'wwg_right_to_back' then
      relative_pos['x']  =  (sizeObj['z']  -sizeBase['x'] ) / 2
      relative_pos['z']  = (sizeObj['x'] + sizeBase['z']) / -2
    elseif direction == 'right_to_wwg_front' then
      relative_pos['x'] = -1*(sizeObj['z'] / 2) + sizeBase['x'] / 2
      relative_pos['z'] = sizeObj['x'] / 2 + sizeBase['z'] / 2
    elseif direction == 'right_to_wwg_back' then
      relative_pos['x'] = sizeObj['z'] / 2 - sizeBase['x'] / 2
      relative_pos['z'] = -1*(sizeObj['x'] / 2 + (sizeBase['z'] / 2))
    elseif direction == 'left_to_wwg_front' then
      relative_pos['x'] = sizeObj['z'] / 2 - sizeBase['x'] / 2
      relative_pos['z'] = sizeObj['x'] / 2 + sizeBase['z'] / 2
    elseif direction == 'left_to_wwg_back' then
      relative_pos['x'] = -1*(sizeObj['z'] / 2) + sizeBase['x'] / 2
      relative_pos['z'] = -1*(sizeObj['x'] / 2 + sizeBase['z'] / 2)
    else
      print_error('Tried to snap ' .. obj.getName() .. ' in unknown direction ' .. direction)
      return
    end

    local new_pos = rotate_point_relative(
        relative_pos, transformBase['position'], transformBase['rotation'])
    new_pos['y'] = transformBase['position']['y']

    obj.setPosition(new_pos)

    print_debug(obj.getName() .. ' rotation ' .. tostring( obj.getRotation() ))
    print_debug(base.getName() .. ' rotation ' .. tostring( base.getRotation() ))
    --local diff = obj.getRotation()['y'] - base.getRotation()['y']
    --print_info(tostring( diff ))
end


-- is the moved base close enough to be snapped to another base?
-- obj base being moved, instance of base_cache
-- base Other base to compare against, instance of base_cache
function is_snapable(obj, base)
  -- Check if the two bases are pretty close
  local pos = obj.getPosition()
  local pos_base = base.getPosition()
  local distance = distance_points_flat_sq(pos, pos_base)

  -- no snap if the distance is too small
  if distance < 0.0001 then
    return false
  end

  local max_distance
  if obj['is_large_base'] and base['is_large_base'] then
    max_distance = g_max_distance_alignment * 16
  elseif obj['is_large_base'] or base['is_large_base'] then
    max_distance = g_max_distance_alignment * 4
  else
    max_distance = g_max_distance_alignment
  end

  local close_enough = distance < max_distance
  return close_enough
end

-- Are two bases close enough to snap?
-- moving_base: Base being moved, instance of base_cache
-- resting_base: Base that will be snapped against, instance of base_cache
-- distance_sq: Square of the distance that the moving_base will have
-- to be moved to snap.
-- return true if the bases are close enough to snap, false if the
-- distance is too large
function is_bases_close_enough_to_snap(moving_base, resting_base, distance_sq)
  -- small distances are always snapped
  if distance_sq <  g_max_corner_distance_snap then
    return true
  end

  -- large distances are never snapped
  if distance_sq >= g_max_corner_distance_snap_intersect_sq then
    return false
  end

  if not moving_base.intersectsWith(resting_base) then
    return false
  end

  -- since the bases are on top of each other which is not legal in
  -- DBA use a larger threshold to determine if we can snap.
  if distance_sq < g_max_corner_distance_snap_intersect_sq then
    return true
  end

  return false
end

-- Find the best snapping rule for a base.
-- obj:  Object being moved, instance of base_cache,
-- base: Resting base that might be snapped against, instance of base_cache.
-- Return table containing the distance squared the object has to
-- be moved to snap, and the best snapping rule, and the base itself.
-- nil if there is no snapping rule that can be used.
function find_best_snap_rule_for_base(obj, base)
  -- Discard fast bases that are too far
  if not is_snapable(obj, base) then
    return nil
  end

  -- minimum distance squared for the best snap seen.
  local best_snap_distance_sq = math.huge
  -- function to execute for the best snap
  local best_snap_fn = nil

  print_debug('Checking snap of ' .. obj.getName()
              .. ' with ' .. base.getName())

  -- Calculate relative position
  local distance

  local transformObj = obj.getTransform()
  local transformBase = base.getTransform()

  distance = distance_back_to_front(transformObj, transformBase)
  if distance < best_snap_distance_sq then
    best_snap_distance_sq = distance
    best_snap_fn = 'infront'
  end

  distance = distance_front_to_back(transformObj, transformBase)
  if distance < best_snap_distance_sq then
    best_snap_distance_sq = distance
    best_snap_fn = 'behind'
  end

  distance = distance_right_to_left_side(transformObj, transformBase)
  if distance < best_snap_distance_sq then
    best_snap_distance_sq = distance
    best_snap_fn = 'left'
  end

  distance = distance_left_to_right_side(transformObj, transformBase)
  if distance < best_snap_distance_sq then
    best_snap_distance_sq = distance
    best_snap_fn = 'right'
  end

  distance = distance_front_to_front(transformObj, transformBase)
  if distance < best_snap_distance_sq then
    best_snap_distance_sq = distance
    best_snap_fn = 'opposite'
  end

  distance = distance_front_to_left(transformObj, transformBase)
  if distance < best_snap_distance_sq then
    best_snap_distance_sq = distance
    best_snap_fn = 'door_left'
  end

  distance = distance_front_to_right(transformObj, transformBase)
  if distance < best_snap_distance_sq then
    best_snap_distance_sq = distance
    best_snap_fn = 'door_right'
  end

  if obj['is_wwg'] then
    print_debug('The base is a WWg, checking special snapping')
    distance = distance_left_to_back(transformObj, transformBase)
    if distance < best_snap_distance_sq then
      best_snap_distance_sq = distance
      best_snap_fn = 'wwg_left_to_back'
    end

    distance = distance_left_to_front(transformObj, transformBase)
    if distance < best_snap_distance_sq then
      best_snap_distance_sq = distance
      best_snap_fn = 'wwg_left_front'
    end

    distance = distance_right_to_back(transformObj, transformBase)
    if distance < best_snap_distance_sq then
      best_snap_distance_sq = distance
      best_snap_fn = 'wwg_right_to_back'
    end

    distance = distance_right_to_front(transformObj, transformBase)
    if distance < best_snap_distance_sq then
      best_snap_distance_sq = distance
      best_snap_fn = 'wwg_right_front'
    end
  end

  if base['is_wwg'] then
    print_debug('Trying to snap against a WWg, checking special positions')
     distance = distance_left_to_back(transformObj, transformBase )
     if distance < best_snap_distance_sq then
       best_snap_distance_sq = distance
       best_snap_fn = 'left_to_wwg_back'
    end

    distance = distance_left_to_front(transformObj, transformBase)
    if distance < best_snap_distance_sq then
      best_snap_distance_sq = distance
      best_snap_fn = 'left_to_wwg_front'
    end

    distance = distance_right_to_back(transformObj, transformBase )
    if distance < best_snap_distance_sq then
      best_snap_distance_sq = distance
      best_snap_fn = 'right_to_wwg_back'
    end

    distance = distance_right_to_front(transformObj, transformBase )
    if distance < best_snap_distance_sq then
      best_snap_distance_sq = distance
      best_snap_fn = 'right_to_wwg_front'
    end
  end

  if nil == best_snap_fn then
    return nil
  end

  return { best_snap_distance_sq=best_snap_distance_sq, best_snap_fn=best_snap_fn, best_base = base}
end


-- find the snap rule that has the closest distance
function min_snap_distance(ruleA, ruleB)
  if ruleA == nil then
    return ruleB
  end
  if ruleB == nil then
    return ruleA
  end
  if ruleA['best_snap_distance_sq'] <= ruleB['best_snap_distance_sq'] then
    return ruleA
  end
  return ruleB
end

-- Find the best snapping rule for all bases.
-- obj:  base being moved, instance of base_cache
-- Return table containing the distance squared the object has to
-- be moved to snap, and the best snapping rule, and the base itself.
-- nil if there is no snapping rule that can be used.
function find_best_snap_rule_for_bases(obj)
  local best_rule = nil
  local bases = get_all_bases()
  for _, base in pairs(bases) do
    local base_cache = build_base_cache(base)
    local base_rule = find_best_snap_rule_for_base(obj, base_cache)
    best_rule = min_snap_distance(best_rule, base_rule)
  end
  if best_rule == nil then
    return nil
  end
  local close_enough = is_bases_close_enough_to_snap(obj, best_rule['best_base'],best_rule['best_snap_distance_sq'])
  if not close_enough then
    return nil
  end
  return best_rule
end


-- If a base being moved is close enough to another base that it would
-- align with then snap to moving base to the aligned position.
-- obj:  base that is being moved.
function snap_picked_base(obj)
    local initial_corners = g_picked_base_initial_transform['corners']

    local pos = obj.getPosition()

    if str_has_substr(obj.getName(), 'Camp') then
        -- Always assume that camps are 40mm depth! This may not always be the
        -- case, in which case this code needs to be changed
        local size_table = g_depth_table_in
        if g_current_table_size == 'large' then
            size_table = g_depth_large_table_in
        end

        local edge_camp_pos = (size_table / 2) - (g_base_width_inches / 2)
        local distance = math.abs(math.abs(pos['z']) - edge_camp_pos)

        print_debug('Camp has pos ' .. pos['z'] .. ' which has distance ' .. distance ..' to the edge ' .. edge_camp_pos)

        if  distance < g_max_camp_edge_snap then
            if pos['z'] > 0 then
                pos['z'] = edge_camp_pos
                obj.setRotation({x=0, y=180, z=0})
            else
                pos['z'] = -edge_camp_pos
                obj.setRotation({x=0, y=0, z=0})
            end
            pos['y'] = g_bases_position
            obj.setPosition(pos)
            print_info('Camp snapped to battle edge')
        else
            print_debug('Moving a camp, which should not snap to anything')
        end

        return calculate_transform(obj)
    end

    local obj_cache = build_base_cache(obj)
    local snap_rule = find_best_snap_rule_for_bases(obj_cache)
    if snap_rule ~= nil then
      local best_base = snap_rule['best_base']['base']
      local best_transform = snap_rule['best_base'].getTransform()
      snap_to_base(obj, obj_cache.getTransform(),
         best_base, best_transform, snap_rule['best_snap_fn'])
      return calculate_transform(obj)
    end

    -- If there's nothing else to snap, maybe I can snap to my initial
    -- position if I moved too little
    local new_transform = calculate_transform(obj)
    local new_corners = new_transform['corners']
    local distance = max_distance_between_bases(new_corners, initial_corners)
    if distance < g_max_inches_snap_reset then
        -- Snap back!
        obj.setPosition(g_picked_base_initial_transform['position'])
        obj.setRotation(transform_to_rotation_vector(g_picked_base_initial_transform))
    else
        -- No snapping, return the distance between positions
        pos['y'] = g_base_height_tabletop + g_table_thickness + g_base_height_inches
        obj.setPosition(pos)
    end
    return calculate_transform(obj)
end

function get_all_bases()
    return filter_bases(getAllObjects())
end

function onObjectDrop(player_color,  picked_up_object)
    local obj_name = picked_up_object.getName()
    if (str_has_substr(obj_name, 'Waterway')) then
        snap_waterway(picked_up_object)
    elseif (str_has_substr(obj_name, 'Road')) then
        snap_road(picked_up_object)
    end

    if g_bases[obj_name] == nil then
        return
    end

    local objs = filter_bases(Player[player_color].getSelectedObjects())
    local n_objs = tlen(objs)
    if n_objs > 1 then
        picked_up_object.setVelocity({x=0, y=0, z=0})
        picked_up_object.setAngularVelocity({x=0, y=0, z=0})
        draw_all_gizmos()
        return
    end

    if g_picked_base_obj == nil or obj_name ~= g_picked_base_obj.getName() then
        -- Ignore, this is not the one we were counting distances
        return
    end

    picked_up_object.setVelocity({x=0, y=0, z=0})
    picked_up_object.setAngularVelocity({x=0, y=0, z=0})

    if g_snap_mode_enabled then
        new_transform = snap_picked_base(picked_up_object)
    else
        new_transform = calculate_transform(picked_up_object)
    end

    local distance = max_distance_between_bases_front_corners(
        new_transform['corners'],
        g_picked_base_initial_transform['corners'])

    if distance > 0 then
        print_info(string.format('Movement for %q is %.2f BW', obj_name, from_in_to_bw(distance)))
        local move = {}
        add_transform_to_move(move, obj_name, g_picked_base_initial_transform, new_transform)
        push_to_history_stack(move)
    else
        print_info(string.format('Movement for %q has been resetted', obj_name))
    end

    g_picked_base_obj = nil
    g_picked_base_initial_transform = nil
    Global.setVectorLines({})

    -- If its dropped it may have moved, therefore update the gizmo, in case
    -- its selected
    draw_all_gizmos()
end

function calculate_future_position(base_obj, movement)
    local rotation = from_degrees_to_rad(base_obj.getRotation())['y']
    local displacement_vector = rad_to_vector(rotation)
    local destination = vec_add(base_obj.getPosition(), vec_mul_escalar(displacement_vector, movement))
    local size = get_size(base_obj.getName())
    local normalized_rotation = normalize_angle(rotation)
    local corners = compute_corners_coords(size, normalized_rotation, destination)

    return get_transform(
        destination,
        corners,
        normalized_rotation
    )
end

function calculate_transform(base_obj)
  local angle_degrees = normalize_degrees(base_obj.getRotation()['y'])
  local angle_rad = math.rad(angle_degrees)
    return {
        position = base_obj.getPosition(),
        corners = compute_corners_base(base_obj),
        rotation = normalize_angle(angle_rad)
    }
end

-- Shape is the corners of the transform is a specific order so adjoining
-- points form an edge, with an implied edge from the last to the
-- first point.
function transform_to_shape(transform)
  local corners = transform['corners']
  return { corners['topleft'], corners['topright'],
      corners['botright'], corners['botleft']  }
end

function transform_to_str(transform)
    if transform == nil then
        return 'NIL'
    end
    if transform['rotation'] == nil then
        print_error('Rotation of the given transform is NULL. Report to the developers!!')
        log(transform)
    end
    return 'Postion: ' .. vec_to_str(transform['position'])
        .. ' Rotation: ' .. math.deg(transform['rotation'])
end

function get_transform(position, corners, rotation)
    return {
        position = position,
        corners = corners,
        rotation = rotation
    }
end

function transform_to_rotation_vector(transform)
    -- The normalization of a normalized is the original
    return {
        x = 0,
        y = math.deg(normalize_angle(transform['rotation'])),
        z = 0
    }
end

function get_closest_transform(pos, transforms)
    local min_distance = nil
    local min_transform = nil

    for base_name, transform in pairs(transforms) do
        local distance = distance_points_flat_sq(transform['corners']['topleft'], pos)
        if min_distance == nil or min_distance > distance then
            min_distance = distance
            min_transform = transform
        end
    end
    return min_transform
end

function on_selection_changed(player_color, new_selected_items)
    if player_color == g_player_wheeling then
        -- If someone is wheeling then changes its selected, deselect and move on
        print_info(Player[player_color].steam_name .. ' has canceled the wheeling by deselecting.')
        on_cancel_wheeling(nil, nil, nil)
        return
    end
    if g_current_wheel_group ~= nil then
        -- Do not draw anything while someone is wheeling
        return
    end
    draw_all_gizmos()
end

function on_zoc_changed()
    if g_current_wheel_group ~= nil then
        -- While someone is wheeling we are not going to update the UI
        return
    end
    draw_all_gizmos()
end

function has_changed_selection_for_player(player_color, selected_objs)
    return not array_equals(
                selected_objs,
                g_selected_objects[player_color],
                function(obj1, obj2)
                    return obj1.guid == obj2.guid
                end)
end

g_selected_objects = {}
g_last_zoc_value = nil

function check_picked_base()
    if g_picked_base_obj and g_bases[g_picked_base_obj.getName()] then
        local new_corners = compute_corners_base(g_picked_base_obj)
        local distance = max_distance_between_bases_front_corners(new_corners, g_picked_base_initial_transform['corners'])
        distance = from_in_to_bw(distance)

        UI.setAttribute('panel_current_movement', 'active', true)
        UI.setValue('text_current_movement_BWs',
            'Current movement: ' .. string.format('%.3f', distance) .. ' BWs' )
    else
        UI.setAttribute('panel_current_movement', 'active', false)
    end
end

function check_selection_change()
    local players = Player.getPlayers()
    for _, player in ipairs(players) do
        local selected_objs = player.getSelectedObjects()
        if has_changed_selection_for_player(player.color, selected_objs) then
            on_selection_changed(player.color, selected_objs)
            g_selected_objects[player.color] = selected_objs
        end
    end
end

function check_change_zoc()
    if g_last_zoc_value ~= g_zoc_enabled then
        -- This affect all players!
        on_zoc_changed()
        g_last_zoc_value = g_zoc_enabled
    end
end

-- Each half a second second execute this
function main_loop()
    check_selection_change()
    check_change_zoc()

    if g_draw_all_gizmos or g_picked_base_obj then
        draw_all_gizmos_execute()
        g_draw_all_gizmos = false
    end
end


-- This function ensures that the internal state of the global vars is
-- consistent with the table.
-- Sadly all bases get assigned red_player because we don't have that info.
-- The tile is also given as an aproximation given the current size.
function reset_state()
    g_selected_objects = {}
    g_picked_base_obj = nil
    g_picked_base_initial_transform = nil
    g_last_zoc_value = nil
    g_current_wheel_group = nil
    g_current_wheel_transforms = nil
    g_current_wheel_newtransforms = nil

    local all_objs = getAllObjects()

    g_bases = {}
    local bases = filter_bases(all_objs)
    for _,base in ipairs(bases) do
        local new_tile = get_closest_tile(base)
        if new_tile == nil then
            print_info('There\'s no appropiate base for ' .. base.getName())
        else
            print_info('Setting ' .. base.getName() .. ' as base')
            g_bases[base.getName()] = {
                tile = new_tile,
                is_red_player = true
            }
            base.clearContextMenu()
            add_context_menu_base(base)
        end
    end

    g_current_table = nil
    for _,obj in ipairs(all_objs) do
        if is_table(obj) then
            g_current_table = obj.getGUID()
            obj.clearContextMenu()
            add_context_menu_table(obj)
            print_info('Setting as current table = ' .. g_current_table)
        end
    end
    print_info('If there\'s terrain on top of the table, please, do a Fix and Lock')

    remove_deployment_lines()
end

function get_closest_tile(base_obj)
    local bounds = base_obj.getBoundsNormalized()
    if bounds == nil or bounds['size'] == nil then
        -- If it has no size its not a proper base and we ignore it
        return false
    end

    local size = bounds['size']
    if math.abs(size['x'] - g_base_width_inches) > 0.01 then
        -- Too wide or too small, ignore
        return true
    end

    if math.abs(size['z'] - from_mm_to_in(15)) < 0.01 then
        return 'tile_grass_40x15'
    end

    if math.abs(size['z'] - from_mm_to_in(20)) < 0.01 then
        return 'tile_grass_40x20'
    end

    if math.abs(size['z'] - from_mm_to_in(30)) < 0.01 then
        return 'tile_grass_40x30'
    end

    if math.abs(size['z'] - from_mm_to_in(40)) < 0.01 then
        return 'tile_grass_40x40'
    end

    if math.abs(size['z'] - from_mm_to_in(60)) < 0.01 then
        return 'tile_grass_40x60'
    end

    if math.abs(size['z'] - from_mm_to_in(80)) < 0.01 then
        return 'tile_grass_40x80'
    end

    return nil
end

function is_table(obj)
    -- There's nothing identifying the table itself, so we use heuristics
    local pos = obj.getPosition()
    if math.abs(pos['x']) > 5 or math.abs(pos['z']) > 5 then
        -- Too far to be a table unless they messed up royally
        return false
    end
    local bounds = obj.getBoundsNormalized()
    if bounds == nil or bounds['size'] == nil then
        -- If it has no size its not a table for sure
        return false
    end

    local size = bounds['size']
    if math.abs(size['x'] - g_width_table_in) < 1 and math.abs(size['z'] - g_depth_table_in) < 1 then
        -- If it's essnetially the same size, it is the table unless they
        -- have summoned something weird
        return true
    end

    if math.abs(size['x'] - 2 * g_width_table_in) < 1 and math.abs(size['z'] - g_depth_table_in) < 1 then
        -- Double DBA!
        return true
    end

    if math.abs(size['x'] - g_width_large_table_in) < 1 and math.abs(size['z'] - g_depth_large_table_in) < 1 then
        -- It's a large table
        return true
    end

    if math.abs(size['x'] - 2 * g_width_large_table_in) < 1 and math.abs(size['z'] - g_depth_large_table_in) < 1 then
        -- Double DBA large table
        return true
    end
    return false
end

function print_state()
    if g_current_table == nil then
        print_info('There\'s no current table.')
    else
        local obj = getObjectFromGUID(g_current_table)
        if obj == nil then
            print_error('There\'s a table stored with GUID ' .. g_current_table
                .. ' but there\'s no object. Please do a !dba_reset.')
        else
            print_info('Current table GUID: ' .. g_current_table)
        end
    end

    if g_bases == nil then
        print_error('There are no bases registered. Please do a !dba_reset.')
    else
        local str = 'The current registered bases are: '
        for base_name,_ in pairs(g_bases) do
            str = str .. base_name .. ', '
        end
        print_info(str)
    end
end
