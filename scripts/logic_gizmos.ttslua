function set_vec_to_above_terrain(vec)
    vec['y'] = g_terrain_pos + g_base_height_inches
    return vec
end

function get_strokes_future_position(base_obj, transform)
    local stroke_points = {}
    table.insert(stroke_points,
        set_vec_to_above_terrain(transform['corners']['topright']))
    table.insert(stroke_points,
        set_vec_to_above_terrain(transform['corners']['topleft']))
    table.insert(stroke_points,
        set_vec_to_above_terrain(transform['corners']['botleft']))
    table.insert(stroke_points,
        set_vec_to_above_terrain(transform['corners']['botright']))
    table.insert(stroke_points,
        set_vec_to_above_terrain(transform['corners']['topright']))

    local color = g_gizmo_color_player_red
    if is_base_blue_player(base_obj.getName()) then
        color = g_gizmo_color_player_blue
    end

    return
    {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_zoc_base(base_obj, transform)
    local stroke_points = {}
    local p = transform['corners']['topright']
    table.insert(stroke_points, p)
    table.insert(stroke_points, {
        x = p['x'],
        y = p['y'],
        z = p['z'] + g_base_width_inches
    })
    table.insert(stroke_points, {
        x = p['x'] - g_base_width_inches,
        y = p['y'],
        z = p['z'] + g_base_width_inches
    })
    table.insert(stroke_points, {
        x = p['x'] - g_base_width_inches,
        y = p['y'],
        z = p['z']
    })
    table.insert(stroke_points, p)

    local rotation = transform['rotation']
    for _, paux in ipairs(stroke_points) do
        local paux_rotated = rotate_point(paux, p, rotation)
        paux['x'] = paux_rotated['x']
        paux['y'] = set_vec_to_above_terrain(paux_rotated)['y']
        paux['z'] = paux_rotated['z']
    end
    return stroke_points
end

function get_strokes_zoc_wwg(base_obj, transform)
    local size = get_size(base_obj.getName())
    local color = g_gizmo_zoc_color_player_red
    if is_base_blue_player(base_obj.getName()) then
        color = g_gizmo_zoc_color_player_blue
    end

    local stroke_points = {}
    local tr = { x = size['x'] / 2, y = 0, z = size['z'] / 2 }
    local tl = { x = -size['x'] / 2, y = 0, z = size['z'] / 2 }
    local br = { x = size['x'] / 2, y = 0, z = -size['z'] / 2 }
    local bl = { x = -size['x'] / 2, y = 0, z = -size['z'] / 2 }

    -- TOP

    table.insert(stroke_points, {
        x = tr['x'],
        y = tr['y'],
        z = tr['z']
    })
    table.insert(stroke_points, {
        x = tr['x'],
        y = tr['y'],
        z = tr['z'] + g_base_width_inches
    })
    table.insert(stroke_points, {
        x = tl['x'],
        y = tl['y'],
        z = tl['z'] + g_base_width_inches
    })
    table.insert(stroke_points, {
        x = tl['x'],
        y = tl['y'],
        z = tl['z']
    })

    -- SIDE LEFT

    table.insert(stroke_points, {
        x = tl['x'] - g_base_width_inches,
        y = tl['y'],
        z = tl['z']
    })
    table.insert(stroke_points, {
        x = bl['x'] - g_base_width_inches,
        y = bl['y'],
        z = bl['z']
    })
    table.insert(stroke_points, {
        x = bl['x'],
        y = bl['y'],
        z = bl['z']
    })

    -- BOTTOM

    table.insert(stroke_points, {
        x = bl['x'],
        y = bl['y'],
        z = bl['z'] - g_base_width_inches
    })
    table.insert(stroke_points, {
        x = br['x'],
        y = br['y'],
        z = br['z'] - g_base_width_inches
    })
    table.insert(stroke_points, {
        x = br['x'],
        y = br['y'],
        z = br['z']
    })

    -- SIDE RIGHT

    table.insert(stroke_points, {
        x = br['x'] + g_base_width_inches,
        y = br['y'],
        z = br['z']
    })
    table.insert(stroke_points, {
        x = tr['x'] + g_base_width_inches,
        y = tr['y'],
        z = tr['z']
    })
    table.insert(stroke_points, {
        x = tr['x'],
        y = tr['y'],
        z = tr['z']
    })

    local rotation = transform['rotation']
    local pos = transform['position']
    for _, paux in ipairs(stroke_points) do
        local paux_rotated = rotate_point_relative(paux, pos, rotation)
        paux['x'] = paux_rotated['x']
        paux['y'] = set_vec_to_above_terrain(paux_rotated)['y']
        paux['z'] = paux_rotated['z']
    end

    return
    {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_zoc(base_obj, transform)
    if str_has_substr(base_obj.getName(), 'Camp') then
        local color = g_gizmo_zoc_color_player_red
        if is_base_blue_player(base_obj.getName()) then
            color = g_gizmo_zoc_color_player_blue
        end

        local size = get_size(base_obj.getName())
        return get_strokes_around(size, transform, g_base_width_inches, color)
    end

    if str_has_substr(base_obj.getName(), 'WWg') then
        local color = g_gizmo_zoc_color_player_red
        if is_base_blue_player(base_obj.getName()) then
            color = g_gizmo_zoc_color_player_blue
        end

        return get_strokes_zoc_wwg(base_obj, transform)
    end

    local stroke_points = {}
    local p = transform['corners']['topright']
    table.insert(stroke_points, p)
    table.insert(stroke_points, {
        x = p['x'],
        y = p['y'],
        z = p['z'] + g_base_width_inches
    })
    table.insert(stroke_points, {
        x = p['x'] - g_base_width_inches,
        y = p['y'],
        z = p['z'] + g_base_width_inches
    })
    table.insert(stroke_points, {
        x = p['x'] - g_base_width_inches,
        y = p['y'],
        z = p['z']
    })
    table.insert(stroke_points, p)

    local rotation = transform['rotation']
    for _, paux in ipairs(stroke_points) do
        local paux_rotated = rotate_point(paux, p, rotation)
        paux['x'] = paux_rotated['x']
        paux['y'] = set_vec_to_above_terrain(paux_rotated)['y']
        paux['z'] = paux_rotated['z']
    end

    local color = g_gizmo_zoc_color_player_red
    if is_base_blue_player(base_obj.getName()) then
        color = g_gizmo_zoc_color_player_blue
    end

    return
    {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end


-- See the DBA2 repo for this, is a bit hellish... Combined with way too many
-- FB discussions that these rules are overly complex
function get_strokes_fire_arc(base_obj, transform, shooting_range, max_width)
    local stroke_points = {}
    local p = transform['corners']['topright']

    local max_angle_arc = math.acos(g_base_width_inches / shooting_range)
    local side_height = math.sin(max_angle_arc) * shooting_range

    table.insert(stroke_points, p)
    table.insert(stroke_points, {
        x = p['x'] + max_width,
        y = p['y'],
        z = p['z']
    })
    table.insert(stroke_points, {
        x = p['x'] + max_width,
        y = p['y'],
        z = p['z'] + side_height
    })
    table.insert(stroke_points, {
        x = p['x'] + max_width,
        y = p['y'],
        z = p['z'] + side_height + max_width
    })
    table.insert(stroke_points, {
        x = p['x'] + max_width,
        y = p['y'],
        z = p['z'] + side_height
    })
    local radius_right = {
        x = p['x'],
        y = p['y'],
        z = p['z']
    }
    local right_arc = get_coordinates_arc(
        radius_right,
        shooting_range,
        g_precision_circle / 4,
        math.deg(max_angle_arc),
        90)
    array_concat(stroke_points, right_arc)
    table.insert(stroke_points, {
        x = p['x'],
        y = p['y'],
        z = p['z'] + shooting_range
    })
    table.insert(stroke_points, {
        x = p['x'] - max_width,
        y = p['y'],
        z = p['z'] + shooting_range
    })
    local radius_left = {
        x = p['x'] - max_width,
        y = p['y'],
        z = p['z']
    }
    local left_arc = get_coordinates_arc(
        radius_left,
        shooting_range,
        g_precision_circle / 4,
        90,
        90 + (90 - math.deg(max_angle_arc)))
    array_concat(stroke_points, left_arc)
    table.insert(stroke_points, {
        x = p['x'] - max_width * 2,
        y = p['y'],
        z = p['z'] + side_height
    })
    table.insert(stroke_points, {
        x = p['x'] - max_width * 2,
        y = p['y'],
        z = p['z'] + side_height + max_width
    })
    table.insert(stroke_points, {
        x = p['x'] - max_width * 2,
        y = p['y'],
        z = p['z'] + side_height
    })
    table.insert(stroke_points, {
        x = p['x'] - max_width * 2,
        y = p['y'],
        z = p['z']
    })
    table.insert(stroke_points, p)

    local rotation = transform['rotation']
    for _, paux in ipairs(stroke_points) do
        local paux_rotated = rotate_point(paux, p, rotation)
        paux['x'] = paux_rotated['x']
        paux['y'] = set_vec_to_above_terrain(paux_rotated)['y']
        paux['z'] = paux_rotated['z']
    end

    local color = g_gizmo_fire_color_player_red
    if is_base_blue_player(base_obj.getName()) then
        color = g_gizmo_fire_color_player_blue
    end

    return
    {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_bow(base_obj, transform)
    return get_strokes_fire_arc(base_obj, transform, g_bow_range, g_base_width_inches)
end

function get_strokes_art(base_obj, transform)
    return get_strokes_fire_arc(base_obj, transform, g_art_range, g_base_width_inches)
end

-- WWg fire with like a bow on all edges which is weird as fuck
function get_strokes_fire_around(size, transform, shooting_range, max_width, color)
    local stroke_points = {}
    local tr = { x = size['x'] / 2, y = 0, z = size['z'] / 2 }
    local tl = { x = -size['x'] / 2, y = 0, z = size['z'] / 2 }
    local br = { x = size['x'] / 2, y = 0, z = -size['z'] / 2 }
    local bl = { x = -size['x'] / 2, y = 0, z = -size['z'] / 2 }

    local max_angle_arc = math.acos(g_base_width_inches / shooting_range)
    local side_height = math.sin(max_angle_arc) * shooting_range

    -- TOP

    table.insert(stroke_points, {
        x = tr['x'] + max_width,
        y = tr['y'],
        z = tr['z'] + max_width
    })
    table.insert(stroke_points, {
        x = tr['x'] + max_width,
        y = tr['y'],
        z = tr['z'] + side_height
    })
    table.insert(stroke_points, {
        x = tr['x'] + max_width,
        y = tr['y'],
        z = tr['z'] + side_height + max_width
    })
    table.insert(stroke_points, {
        x = tr['x'] + max_width,
        y = tr['y'],
        z = tr['z'] + side_height
    })
    local top_right_arc = get_coordinates_arc(
        tr,
        shooting_range,
        g_precision_circle / 4,
        math.deg(max_angle_arc),
        90)
    array_concat(stroke_points, top_right_arc)
    table.insert(stroke_points, {
        x = tr['x'] - size['x'],
        y = tr['y'],
        z = tr['z'] + shooting_range
    })
    local top_left_arc = get_coordinates_arc(
        tl,
        shooting_range,
        g_precision_circle / 4,
        90,
        90 + (90 - math.deg(max_angle_arc)))
    array_concat(stroke_points, top_left_arc)
    table.insert(stroke_points, {
        x = tr['x'] - size['x'] - max_width,
        y = tr['y'],
        z = tr['z'] + side_height
    })
    table.insert(stroke_points, {
        x = tr['x'] - size['x'] - max_width,
        y = tr['y'],
        z = tr['z'] + side_height + max_width
    })
    table.insert(stroke_points, {
        x = tr['x'] - size['x'] - max_width,
        y = tr['y'],
        z = tr['z'] + side_height
    })
    table.insert(stroke_points, {
        x = tr['x'] - size['x'] - max_width,
        y = tr['y'],
        z = tr['z'] + max_width
    })
    table.insert(stroke_points, {
        x = tr['x'] - size['x'] - side_height,
        y = tr['y'],
        z = tr['z'] + max_width
    })
    table.insert(stroke_points, {
        x = tr['x'] - size['x'] - side_height - max_width,
        y = tr['y'],
        z = tr['z'] + max_width
    })
    table.insert(stroke_points, {
        x = tr['x'] - size['x'] - side_height,
        y = tr['y'],
        z = tr['z'] + max_width
    })
    local middleleft_top_arc = get_coordinates_arc(
        tl,
        shooting_range,
        g_precision_circle / 4,
        180 - (90 - math.deg(max_angle_arc)),
        180)
    array_concat(stroke_points, middleleft_top_arc)
    table.insert(stroke_points, {
        x = tr['x'] - size['x'] - shooting_range,
        y = tr['y'],
        z = tr['z']
    })

    -- Bottom

    table.insert(stroke_points, {
        x = br['x'] - size['x'] - shooting_range,
        y = br['y'],
        z = br['z']
    })
    local middleleft_bot_arc = get_coordinates_arc(
        bl,
        shooting_range,
        g_precision_circle / 4,
        180,
        180 + (90 - math.deg(max_angle_arc)))
    array_concat(stroke_points, middleleft_bot_arc)
    table.insert(stroke_points, {
        x = br['x'] - size['x'] - side_height,
        y = br['y'],
        z = br['z'] - max_width
    })
    table.insert(stroke_points, {
        x = br['x'] - size['x'] - side_height - max_width,
        y = br['y'],
        z = br['z'] - max_width
    })
    table.insert(stroke_points, {
        x = br['x'] - size['x'] - side_height,
        y = br['y'],
        z = br['z'] - max_width
    })
    table.insert(stroke_points, {
        x = br['x'] - size['x'] - max_width,
        y = br['y'],
        z = br['z'] - max_width
    })
    table.insert(stroke_points, {
        x = br['x'] - size['x'] - max_width,
        y = br['y'],
        z = br['z'] - side_height
    })
    table.insert(stroke_points, {
        x = br['x'] - size['x'] - max_width,
        y = br['y'],
        z = br['z'] - side_height - max_width
    })
    table.insert(stroke_points, {
        x = br['x'] - size['x'] - max_width,
        y = br['y'],
        z = br['z'] - side_height
    })
    local left_bot_arc = get_coordinates_arc(
        bl,
        shooting_range,
        g_precision_circle / 4,
        270 - (90 - math.deg(max_angle_arc)),
        270)
    array_concat(stroke_points, left_bot_arc)
    table.insert(stroke_points, {
        x = br['x'] - size['x'],
        y = br['y'],
        z = br['z'] - shooting_range
    })
    table.insert(stroke_points, {
        x = br['x'],
        y = br['y'],
        z = br['z'] - shooting_range
    })
    local right_bot_arc = get_coordinates_arc(
        br,
        shooting_range,
        g_precision_circle / 4,
        270,
        270 + (90 - math.deg(max_angle_arc)))
    array_concat(stroke_points, right_bot_arc)
    table.insert(stroke_points, {
        x = br['x'] + max_width,
        y = br['y'],
        z = br['z'] - side_height
    })
    table.insert(stroke_points, {
        x = br['x'] + max_width,
        y = br['y'],
        z = br['z'] - side_height - max_width
    })
    table.insert(stroke_points, {
        x = br['x'] + max_width,
        y = br['y'],
        z = br['z'] - side_height
    })
    table.insert(stroke_points, {
        x = br['x'] + max_width,
        y = br['y'],
        z = br['z'] - max_width
    })
    table.insert(stroke_points, {
        x = br['x'] + side_height,
        y = br['y'],
        z = br['z'] - max_width
    })
    table.insert(stroke_points, {
        x = br['x'] + side_height + max_width,
        y = br['y'],
        z = br['z'] - max_width
    })
    table.insert(stroke_points, {
        x = br['x'] + side_height,
        y = br['y'],
        z = br['z'] - max_width
    })
    local middleright_bot_arc = get_coordinates_arc(
        br,
        shooting_range,
        g_precision_circle / 4,
        360 - (90 - math.deg(max_angle_arc)),
        360)
    array_concat(stroke_points, middleright_bot_arc)
    table.insert(stroke_points, {
        x = br['x'] + shooting_range,
        y = br['y'],
        z = br['z']
    })

    -- TOP

    table.insert(stroke_points, {
        x = tr['x'] + shooting_range,
        y = tr['y'],
        z = tr['z']
    })
    local middleright_top_arc = get_coordinates_arc(
        tr,
        shooting_range,
        g_precision_circle / 4,
        0,
        90 - math.deg(max_angle_arc))
    array_concat(stroke_points, middleright_top_arc)
    table.insert(stroke_points, {
        x = tr['x'] + side_height,
        y = tr['y'],
        z = tr['z'] + max_width
    })
    table.insert(stroke_points, {
        x = tr['x'] + side_height + max_width,
        y = tr['y'],
        z = tr['z'] + max_width
    })
    table.insert(stroke_points, {
        x = tr['x'] + side_height,
        y = tr['y'],
        z = tr['z'] + max_width
    })
    table.insert(stroke_points, {
        x = tr['x'] + max_width,
        y = tr['y'],
        z = tr['z'] + max_width
    })

    local rotation = transform['rotation']
    local pos = transform['position']
    for _, paux in ipairs(stroke_points) do
        local paux_rotated = rotate_point_relative(paux, pos, rotation)
        paux['x'] = paux_rotated['x']
        paux['y'] = set_vec_to_above_terrain(paux_rotated)['y']
        paux['z'] = paux_rotated['z']
    end

    return
    {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_wwg(base_obj, transform)
    local size = get_size(base_obj.getName())
    local color = g_gizmo_fire_color_player_red
    if is_base_blue_player(base_obj.getName()) then
        color = g_gizmo_fire_color_player_blue
    end
    return get_strokes_fire_around(size, transform, g_wwg_range, g_base_width_inches, color)
end

function get_strokes_around(size, transform, range, color)
    local stroke_points = {}
    local p = transform['corners']['topright']
    local depth = size['z']
    local width = size['x']

    table.insert(stroke_points, {
        x = p['x'],
        y = p['y'],
        z = p['z'] + range
    })
    table.insert(stroke_points, {
        x = p['x'] - width,
        y = p['y'],
        z = p['z'] + range
    })
    local radius_topleft = {
        x = p['x'] - width,
        y = p['y'],
        z = p['z']
    }
    local topleft_arc = get_coordinates_arc(
        radius_topleft,
        range,
        g_precision_circle / 4,
        90,
        180)
    array_concat(stroke_points, topleft_arc)
    table.insert(stroke_points, {
        x = p['x'] - width - range,
        y = p['y'],
        z = p['z']
    })
    table.insert(stroke_points, {
        x = p['x'] - width - range,
        y = p['y'],
        z = p['z'] - depth
    })
    local radius_botleft = {
        x = p['x'] - width,
        y = p['y'],
        z = p['z'] - depth
    }
    local botleft_arc = get_coordinates_arc(
        radius_botleft,
        range,
        g_precision_circle / 4,
        180,
        270)
    array_concat(stroke_points, botleft_arc)
    table.insert(stroke_points, {
        x = p['x'] - width,
        y = p['y'],
        z = p['z'] - depth - range
    })
    table.insert(stroke_points, {
        x = p['x'],
        y = p['y'],
        z = p['z'] - depth - range
    })
    local radius_botright = {
        x = p['x'],
        y = p['y'],
        z = p['z'] - depth
    }
    local botright_arc = get_coordinates_arc(
        radius_botright,
        range,
        g_precision_circle / 4,
        270,
        360)
    array_concat(stroke_points, botright_arc)
    table.insert(stroke_points, {
        x = p['x'] + range,
        y = p['y'],
        z = p['z'] - depth
    })
    table.insert(stroke_points, {
        x = p['x'] + range,
        y = p['y'],
        z = p['z']
    })
    local radius_topright = {
        x = p['x'],
        y = p['y'],
        z = p['z']
    }
    local topright_arc = get_coordinates_arc(
        radius_topright,
        range,
        g_precision_circle / 4,
        0,
        90)
    array_concat(stroke_points, topright_arc)
    table.insert(stroke_points, {
        x = p['x'],
        y = p['y'],
        z = p['z'] + range
    })

    local rotation = transform['rotation']
    for _, paux in ipairs(stroke_points) do
        local paux_rotated = rotate_point(paux, p, rotation)
        paux['x'] = paux_rotated['x']
        paux['y'] = set_vec_to_above_terrain(paux_rotated)['y']
        paux['z'] = paux_rotated['z']
    end

    return
    {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_command(base_obj, transform, range)
    local size = get_size(base_obj.getName())
    return get_strokes_around(size, transform, range, g_gizmo_color_command)
end

function get_strokes_base_pos(obj, transform)
    local strokes = {}

    table.insert(strokes, get_strokes_future_position(obj, transform))

    if str_has_substr(obj.getName(), 'Bw')
       or str_has_substr(obj.getName(), 'Cb')
       or str_has_substr(obj.getName(), 'Lb') then
        table.insert(strokes, get_strokes_bow(obj, transform))
    elseif str_has_substr(obj.getName(), 'Art') then
        table.insert(strokes, get_strokes_art(obj, transform))
    elseif str_has_substr(obj.getName(), 'WWg') then
        table.insert(strokes, get_strokes_wwg(obj, transform))
    end

    if str_has_substr(obj.getName(), 'Gen') then
        table.insert(strokes, get_strokes_command(obj, transform, g_command_distance_short))
        table.insert(strokes, get_strokes_command(obj, transform, g_command_distance_long))
    end

    if g_zoc_enabled then
        table.insert(strokes, get_strokes_zoc(obj, transform))
    end
    return strokes
end

function get_strokes_pickup(picked_up_object)
    if picked_up_object == nil then
        return {}
    end
    local pos = g_picked_base_initial_transform['position']
    local radius = from_bw_to_in(g_bw_movement)

    local color = g_gizmo_color_player_red
    if is_base_blue_player(picked_up_object.getName()) then
        color = g_gizmo_color_player_blue
    end

    local strokes = {}
    table.insert(strokes, get_strokes_arrow_position(picked_up_object, g_picked_base_initial_transform))
    table.insert(strokes, {
        points    = get_coordinates_circle(pos, radius, g_precision_circle),
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    })
    local transform = calculate_transform(picked_up_object)
    local height = g_picked_base_initial_transform['position'].y
    transform['corners']['topright'] = {
        x = transform['corners']['topright'].x, y = height, z = transform['corners']['topright'].z
    }
    transform['corners']['topleft'] = {
        x = transform['corners']['topleft'].x, y = height, z = transform['corners']['topleft'].z
    }
    transform['corners']['botleft'] = {
        x = transform['corners']['botleft'].x, y = height, z = transform['corners']['botleft'].z
    }
    transform['corners']['topright'] = {
        x = transform['corners']['topright'].x, y = height, z = transform['corners']['topright'].z
    }
    transform['corners']['botright'] = {
        x = transform['corners']['botright'].x, y = height, z = transform['corners']['botright'].z
    }
    array_concat(strokes, get_strokes_base_pos(picked_up_object, transform))
    return strokes
end

function get_strokes_future_movements(new_selected_items)
    if new_selected_items == nil or #new_selected_items == 0 then
        return {}
    end

    local strokes = {}
    local magnitude = from_bw_to_in(g_bw_movement)
    for _, obj in ipairs(new_selected_items) do
        if g_bases[obj.getName()] ~= nil then
            local transform = calculate_future_position(obj, magnitude)

            array_concat(strokes, get_strokes_base_pos(obj, transform))
        end

    end
    return strokes
end

-- This caches the strokes for a given base in certain pos and rotation
-- g_cache_zocs["basename"] =  {
--      "pos" = {x=1,y=1,z=1}
--      "rot" = {x=1,y=1,z=1}
--      "strokes" = {}
--   }
g_cache_zocs = {}

function get_strokes_bases_nothing(bases)
    if bases == nil or #bases == 0 then
        return {}
    end

    local strokes = {}
    for _, obj in ipairs(bases) do
        if g_zoc_enabled then
            local name = obj.getName()
            local pos = obj.getPosition()
            local rot = obj.getRotation()
            if g_cache_zocs[name]
                and g_cache_zocs[name].pos == pos
                and g_cache_zocs[name].rot == rot then

                table.insert(strokes, g_cache_zocs[name].strokes)
            else
                local base_strokes = get_strokes_zoc(obj, calculate_transform(obj))
                table.insert(strokes, base_strokes)
                g_cache_zocs[name] = {}
                g_cache_zocs[name].pos = pos
                g_cache_zocs[name].rot = rot
                g_cache_zocs[name].strokes = base_strokes
            end
        end
    end
    return strokes
end

function get_bases_for_gizmos()
    local all_objs = getAllObjects()
    local bases = get_bases_with_guid(all_objs)

    local picked_base = nil
    if g_picked_base_obj then
        if bases[g_picked_base_obj.getGUID()] then
            picked_base = g_picked_base_obj
            bases[g_picked_base_obj.getGUID()] = nil
        end

    end
    local bases_selected = {}
    local player_colors = getSeatedPlayers()
    for _, player_color in ipairs(player_colors) do
        local selected_bases_player = Player[player_color].getSelectedObjects()
        if selected_bases_player then
          for _, base in ipairs(selected_bases_player) do
              if bases[base.getGUID()] then
                  table.insert(bases_selected, base)
                  bases[base.getGUID()] = nil
              end
          end
      end
    end

    local other_bases = {}
    for _,base in pairs(bases) do
        table.insert(other_bases, base)
    end

    return bases_selected, picked_base, other_bases
end

function draw_all_gizmos()
    g_draw_all_gizmos = true
end

function draw_all_gizmos_execute()
    local strokes = {}
    -- This is terrible code!
    local moving_selected_items, pickedup_object, other_bases = get_bases_for_gizmos()

    local t1 = os.clock()
    if pickedup_object then
        array_concat(strokes, get_strokes_pickup(pickedup_object))
    end
    if moving_selected_items and #moving_selected_items > 0 then
        array_concat(strokes, get_strokes_future_movements(moving_selected_items))
    end
    if g_zoc_enabled then
        array_concat(strokes, get_strokes_bases_nothing(other_bases))
    end
    Global.setVectorLines(strokes)
end

function draw_gizmo_wheeling(transforms)
    local strokes = {}
    for obj,transform in pairs(transforms) do
        table.insert(strokes, get_strokes_future_position(obj, transform))
    end
    Global.setVectorLines(strokes)
end

function get_strokes_deployment(pos, color, angle, proportion, width, depth)
    local zpos = 1

    if pos == 'bot' then
        zpos = -1
    end

    local half_width = width / 2
    local half_depth = depth / 2

    local stroke_points = {}
    local center = { x=0, y=0, z=0 }
    table.insert(stroke_points, rotate_point_relative({
        x = - half_width + from_bw_to_in(2) / proportion,
        y = g_table_thickness + g_base_height_inches / 2,
        z = zpos * half_depth
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = - half_width + from_bw_to_in(2) / proportion,
        y = g_table_thickness + g_base_height_inches / 2,
        z = zpos * from_bw_to_in(3) / proportion
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = - half_width + from_bw_to_in(4) / proportion,
        y = g_table_thickness + g_base_height_inches / 2,
        z = zpos * from_bw_to_in(3) / proportion
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = - half_width + from_bw_to_in(4) / proportion,
        y = g_table_thickness + g_base_height_inches / 2,
        z = zpos * half_depth
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = - half_width + from_bw_to_in(4) / proportion,
        y = g_table_thickness + g_base_height_inches / 2,
        z = zpos * from_bw_to_in(3) / proportion
    }, center, -angle))

    table.insert(stroke_points, rotate_point_relative({
        x = half_width -from_bw_to_in(4) / proportion,
        y = g_table_thickness + g_base_height_inches / 2,
        z = zpos * from_bw_to_in(3) / proportion
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = half_width - from_bw_to_in(4) / proportion,
        y = g_table_thickness + g_base_height_inches / 2,
        z = zpos * half_depth
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = half_width - from_bw_to_in(4) / proportion,
        y = g_table_thickness + g_base_height_inches / 2,
        z = zpos * from_bw_to_in(3) / proportion
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = half_width - from_bw_to_in(2) / proportion,
        y = g_table_thickness + g_base_height_inches / 2,
        z = zpos * from_bw_to_in(3) / proportion
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = half_width - from_bw_to_in(2) / proportion,
        y = g_table_thickness + g_base_height_inches / 2,
        z = zpos * half_depth
    }, center, -angle))

    return {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_quadrant_horizontal(angle, width, depth)
    local stroke_points = {}
    local center = { x=0, y=0, z=0 }
    local half_width = width / 2
    local half_depth = depth / 2
    table.insert(stroke_points, rotate_point_relative({
        x = -half_width,
        y = g_table_thickness + g_base_height_inches / 2,
        z = 0
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = half_width,
        y = g_table_thickness + g_base_height_inches / 2,
        z = 0
    }, center, -angle))

    return {
        points    = stroke_points,
        color     = g_gizmo_color_command,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_quadrant_vertical(angle, width, depth)
    local stroke_points = {}
    local center = { x=0, y=0, z=0 }
    local half_width = width / 2
    local half_depth = depth / 2
    table.insert(stroke_points, rotate_point_relative({
        x = 0,
        y = g_table_thickness + g_base_height_inches / 2,
        z = half_depth
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = 0,
        y = g_table_thickness + g_base_height_inches / 2,
        z = -half_depth
    }, center, -angle))

    return {
        points    = stroke_points,
        color     = g_gizmo_color_command,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function spawn_text(text, pos)
    local params = {
        type = '3DText',
        position = pos,
        rotation = { 90, 0, 0 }
    }
    local obj = spawnObject(params)
    obj.setValue(text)
    obj.TextTool.setFontSize(180)
    obj.setName('Text ' .. text)
    return obj
end

function draw_numbers_quadrant(size)
    local height_text = g_table_thickness * 2 + g_base_height_tabletop + g_base_height_inches / 2

    spawn_text('1', { -size['x'] / 4, height_text, -size['z'] / 4})

    spawn_text('2', { -size['x'] / 4, height_text, size['z'] / 4})

    spawn_text('3', { size['x'] / 4, height_text, size['z'] / 4})

    spawn_text('4', { size['x'] / 4, height_text, -size['z'] / 4})
end

function draw_deployment_lines()
    local gametable = getObjectFromGUID(g_current_table)
    if gametable == nil then
        print_error('There is no current table, stored GUID is: ' .. g_current_table)
        return
    end

    local size = gametable.getBoundsNormalized()['size']
    local scale = gametable.getScale()
    local proportion = scale['x']
    local angle = normalize_angle(math.rad(gametable.getRotation()['y']))
    local w = size['x']  / scale['x']
    local h = size['z'] / scale['z']

    local strokes = {}
    table.insert(strokes,
        get_strokes_deployment('top',
            g_gizmo_color_player_blue, angle, proportion, w, h))
    table.insert(strokes,
        get_strokes_deployment('bot',
            g_gizmo_color_player_red, angle, proportion, w, h))
    table.insert(strokes, get_strokes_quadrant_vertical(angle, w, h))
    table.insert(strokes, get_strokes_quadrant_horizontal(angle, w, h))

    gametable.setVectorLines(strokes)
    draw_numbers_quadrant(size)
end

function remove_deployment_lines()
    local gametable = getObjectFromGUID(g_current_table)
    if gametable ~= nil then
        gametable.setVectorLines({})
    end
    local all_objs = getAllObjects()
    for _,obj in ipairs(all_objs) do
        local name = obj.getName()
        if str_starts_with(name, 'Text ') then
            -- This executes on next frame
            obj.destroy()
        end
    end
end

function get_strokes_arrow_position(base_obj, transform)
    local stroke_points = {}
    local p = transform['position']
    table.insert(stroke_points, p)
    table.insert(stroke_points, {
        x = p['x'],
        y = p['y'],
        z = p['z'] + 2
    })
    table.insert(stroke_points, {
        x = p['x'] - 1,
        y = p['y'],
        z = p['z'] + 1.5
    })
    table.insert(stroke_points, {
        x = p['x'],
        y = p['y'],
        z = p['z'] + 2
    })
    table.insert(stroke_points, {
        x = p['x'] + 1,
        y = p['y'],
        z = p['z'] + 1.5
    })
    table.insert(stroke_points, {
        x = p['x'],
        y = p['y'],
        z = p['z'] + 2
    })

    local rotation = transform['rotation']
    for _, paux in ipairs(stroke_points) do
        local paux_rotated = rotate_point(paux, p, rotation)
        paux['x'] = paux_rotated['x']
        paux['y'] = set_vec_to_above_terrain(paux_rotated)['y']
        paux['z'] = paux_rotated['z']
    end

    local color = g_gizmo_color_player_red
    if is_base_blue_player(base_obj.getName()) then
        color = g_gizmo_color_player_blue
    end

    return
    {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end


function show_gizmo_bua_afterdetach()
    local gametable = getObjectFromGUID(g_current_table)
    local all_objs = getAllObjects()
    local terrains = {}
    for _,obj in ipairs(all_objs) do
        local name = obj.getName()
        if str_starts_with(name, 'terrain') then
            table.insert(terrains, obj)
        end
    end

    local max_distance_from_table_sq = (g_width_table_in/2)^2 + (g_depth_table_in / 2)^2
    local pos_table = gametable.getPosition()

    local table_height = gametable.getPosition()['y']
    local height_strokes = table_height + g_table_thickness / 2 + g_base_height_inches / 2

    local strokes = {}
    for _,terrain in ipairs(terrains) do
        local terrain_pos = terrain.getPosition()
        local distance = distance_points_flat_sq(pos_table, terrain_pos)
        if distance <= max_distance_from_table_sq
            and pos_table['y'] < terrain_pos['y'] then

            if str_starts_with(terrain.getName(), 'terrain BUA') then

                print_debug('There\'s a BUA at position ' .. vec_to_str(terrain_pos))

                terrain_pos['y'] = height_strokes

                local angle = normalize_angle(math.rad(terrain.getRotation()['y']))
                local scale = terrain.getScale()
                local size = terrain.getBoundsNormalized()['size']
                size = vec_mul_vec(size, scale)
                local corners = compute_corners_coords(size, angle, terrain_pos)
                local transform = get_transform(terrain_pos, corners, angle)

                local strokes_zoc = get_strokes_around(size, transform, g_base_width_inches, g_gizmo_color_command)
                local strokes_bw = get_strokes_around(size, transform, g_bow_range, g_gizmo_color_command)
                local strokes_art = get_strokes_around(size, transform, g_art_range,  g_gizmo_color_command)

                table.insert(strokes, strokes_zoc)
                table.insert(strokes, strokes_bw)
                table.insert(strokes, strokes_art)
            end
            terrain.setLock(true)
        end
    end
    print_debug('Recalculation for fire gizmos BUAs done')
    Global.setVectorLines(strokes)
end

function show_gizmo_bua()
    local gametable = getObjectFromGUID(g_current_table)
    if gametable == nil then
        print_error('There is no current table, stored GUID is: ' .. g_current_table)
        return
    end

    Wait.frames(show_gizmo_bua_afterdetach, 1)
end
