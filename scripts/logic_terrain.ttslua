
function snap_waterway(waterway)
    if g_current_table == nil then
        print_debug('No table spawned yet, no need to do anything')
        return
    end
    local gametable = getObjectFromGUID(g_current_table)
    if gametable == nil then
        print_error('There is no current table, stored GUID is: ' .. g_current_table)
        return
    end

    local table_size = gametable.getBoundsNormalized()['size']
    local table_w = table_size['x']
    local table_h = table_size['z']

    -- 0 rotation for our waterway objects is looking at -z
    local rotation = normalize_angle(math.rad(waterway.getRotation()['y']))
    local pos = waterway.getPosition()
    local bounds = waterway.getBoundsNormalized()

    local h = bounds['size']['z']
    local zpos = table_h / 2 - (h / 2 - bounds['offset']['z'])
    local xpos = table_w / 2 - (h / 2 - bounds['offset']['z'])
    if g_is_double_dba then
        xpos = xpos + table_w / 2
    end

    if (equals_float(rotation, 0, 0.17) or equals_float(rotation, 2*math.pi, 0.17))
        and equals_float(pos['x'], 0, g_max_camp_edge_snap)
        and equals_float(pos['z'], zpos, g_max_camp_edge_snap)
        then

        waterway.setPosition({x=0, y=g_terrain_pos, z=zpos})
        waterway.setRotation({x=0, y=0, z=0})
        print_info('Waterway Snapping top')

    elseif equals_float(rotation, math.pi/2, 0.17)
        and equals_float(pos['x'], -xpos, g_max_camp_edge_snap)
        and equals_float(pos['z'], 0, g_max_camp_edge_snap)
        then

        waterway.setPosition({x=-xpos, y=g_terrain_pos, z=0})
        waterway.setRotation({x=0, y=270, z=0})
        print_info('Waterway Snapping left')

    elseif equals_float(rotation, math.pi, 0.17)
        and equals_float(pos['x'], 0, g_max_camp_edge_snap)
        and equals_float(pos['z'], -zpos, g_max_camp_edge_snap)
        then

        waterway.setPosition({x=0, y=g_terrain_pos, z=-zpos})
        waterway.setRotation({x=0, y=180, z=0})
        print_info('Waterway Snapping bot')

    elseif equals_float(rotation, math.pi*3/2, 0.17)
        and equals_float(pos['x'], xpos, g_max_camp_edge_snap)
        and equals_float(pos['z'], 0, g_max_camp_edge_snap)
        then

        waterway.setPosition({x=xpos, y=g_terrain_pos, z=0})
        waterway.setRotation({x=0, y=90, z=0})
        print_info('Waterway Snapping right')

    else
        print_info('Waterway is not snapping')
    end
end

function snap_road(road)
    -- 0 rotation for our waterway objects is looking at -z
    local rotation = normalize_angle(math.rad(road.getRotation()['y']))
    local pos = road.getPosition()

    if (equals_float(rotation, 0, 0.17)
        or equals_float(rotation, math.pi, 0.17)
        or equals_float(rotation, 2*math.pi, 0.17))
        and equals_float(pos['z'], 0, g_max_camp_edge_snap)
        then

        road.setPosition({x=pos['x'], y=g_terrain_pos, z=0})
        road.setRotation({x=0, y=0, z=0})
        print_info('Road Snapping Vertical')

    elseif (equals_float(rotation, math.pi/2, 0.17)
            or equals_float(rotation, 3*math.pi/2, 0.17))
            and equals_float(pos['x'], 0, g_max_camp_edge_snap)
        then

        road.setPosition({x=0, y=g_terrain_pos, z=pos['z']})
        road.setRotation({x=0, y=90, z=0})
        print_info('Road Snapping Horizontal')

    else
        print_info('Road is not snapping')
    end
end


function fix_terrain_and_lock()
    local all_objs = getAllObjects()
    local terrains = {}
    for _,obj in ipairs(all_objs) do
        local name = obj.getName()
        if str_starts_with(name, 'terrain') then
            table.insert(terrains, obj)
        end
    end

    local gametable = getObjectFromGUID(g_current_table)
    local size = gametable.getBoundsNormalized()['size']
    local max_distance_from_table_sq = (size['x']/2)^2 + (size['z'] / 2)^2
    local pos_table = gametable.getPosition()
    local terrain_type = from_toggle_number_to_table_type(g_current_table_type)

    gametable.setLock(false)
    for _,terrain in ipairs(terrains) do
        local terrain_pos = terrain.getPosition()
        local distance = distance_points_flat_sq(pos_table, terrain_pos)
        if distance <= max_distance_from_table_sq
            and pos_table['y'] < terrain_pos['y'] then

            print_debug('Found terrain with name ' .. terrain.getName())

            local current_scale = terrain.getScale()
            print_debug('The terrain had scale ' .. vec_to_str(current_scale))
            if str_has_substr(terrain.getName(), 'Road') then
                current_scale.y = 0.8 + math.random()*0.1 - 0.05
            else
                current_scale.y = 0.1
            end
            terrain.setScale(current_scale)

            local current_rotation = terrain.getRotation()
            print_debug('The terrain had rotation ' .. vec_to_str(current_rotation))
            current_rotation.x = 0
            current_rotation.z = 0
            terrain.setRotation(current_rotation)

            local current_pos = terrain.getPosition()
            print_debug('The terrain had position ' .. vec_to_str(current_pos))
            current_pos.y = g_terrain_pos
            terrain.setPosition(current_pos)

            Wait.frames(function ()
                if g_use_3d_terrain then
                    process_vegetation(terrain, terrain_type)
                end

                gametable.addAttachment(terrain)
                print_info('Attaching ' .. terrain.getName())
            end, 1)
        end
    end
    Wait.frames(function()
        g_current_table = gametable.getGUID()
        gametable.setRotation({ x = 0, y = 0, z = 0})
        gametable.setPosition({ x = 0, y = g_base_height_tabletop, z = 0})
        gametable.setLock(true)
        print_important('Table is now locked')
    end, 1)
end

function change_texture_terrain(terrain_obj, new_tex_url)
    local custom = terrain_obj.getCustomObject()
    custom['diffuse'] = new_tex_url
    terrain_obj.setCustomObject(custom)
end

function set_forest(terrain_obj, terrain_pos, terrain_rotation, terrain_size, table_type)
    local options = g_terrain[table_type]['forest']
    local multiplier = options['multiplier']
    local ntrees = math.floor((terrain_size['x'] + terrain_size['z'])*multiplier)
    for i=1,ntrees do
        local point = random_point_ellipse(terrain_size['x'] / 2.5, terrain_size['z'] / 2.5)
        new_pos = rotate_point_relative(point, terrain_pos, terrain_rotation)
        local obj = spawn_model(random_element(options['objects']), new_pos, math.random(1, 359), minimal_collider, true)
        terrain_obj.addAttachment(obj)
    end
    change_texture_terrain(terrain_obj, random_element(options['texture']))
end

function set_arid(terrain_obj, terrain_pos, terrain_rotation, terrain_size, table_type)
    local options = g_terrain[table_type]['rough']
    local nobjs = math.floor((terrain_size['x'] + terrain_size['z'])*2)
    for i=1,nobjs do
        local point = random_point_ellipse(terrain_size['x'] / 2.5, terrain_size['z'] / 2.5)
        new_pos = rotate_point_relative(point, terrain_pos, terrain_rotation)
        local obj = spawn_model(random_element(options['objects']), new_pos, math.random(1, 359), minimal_collider, true)
        terrain_obj.addAttachment(obj)
    end
    change_texture_terrain(terrain_obj, random_element(options['texture']))
end

function set_oasis(terrain_obj, terrain_pos, terrain_rotation, terrain_size, table_type)
    local options = g_terrain[table_type]['oasis']
    local nobjs = math.floor((terrain_size['x'] + terrain_size['z'])*1.2)
    for i=1,nobjs do
        local point = random_point_ellipse(terrain_size['x'] / 4, terrain_size['z'] / 4,
            math.min(terrain_size['x'] / 4, terrain_size['z'] / 4) - 0.3)

        new_pos = rotate_point_relative(point, terrain_pos, terrain_rotation)
        local obj = spawn_model(random_element(options['objects']), new_pos, math.random(1, 359), minimal_collider, true)
        terrain_obj.addAttachment(obj)
    end
    change_texture_terrain(terrain_obj, random_element(options['texture']))
end

function set_marsh(terrain_obj, terrain_pos, terrain_rotation, terrain_size, table_type)
    local options = g_terrain[table_type]['marsh']
    local nobjs = math.floor((terrain_size['x'] + terrain_size['z'])*1.2)
    for i=1,nobjs do
        local point = random_point_ellipse(terrain_size['x'] / 4, terrain_size['z'] / 4,
            math.min(terrain_size['x'] / 4, terrain_size['z'] / 4) - 0.3)

        new_pos = rotate_point_relative(point, terrain_pos, terrain_rotation)
        local obj = spawn_model(random_element(options['objects']), new_pos, math.random(1, 359), minimal_collider, true)
        terrain_obj.addAttachment(obj)
    end
    change_texture_terrain(terrain_obj, random_element(options['texture']))
end


function set_plough(terrain_obj, terrain_pos, terrain_rotation, terrain_size, table_type)
    local options = g_terrain[table_type]['plough']
    local objs_x = math.floor(terrain_size['x'])
    local margin_x = (terrain_size['x'] - objs_x) / 2
    local objs_z = math.floor(terrain_size['z'])
    local margin_z = (terrain_size['z'] - objs_z) / 2

    local plough_asset = first_value_table(options['objects'])

    for i=1,objs_x do
        for j=1,objs_z do
            local point = {
                x = margin_x + 0.5 + i - 1 - terrain_size['x'] / 2,
                y = 0,
                z = margin_z + 0.5 + j - 1 - terrain_size['z'] / 2
            }
            local new_pos = rotate_point_relative(point, terrain_pos, terrain_rotation)
            local obj = spawn_asset(plough_asset, new_pos, terrain_obj.getRotation()['y'])
            terrain_obj.addAttachment(obj)
        end
    end
    change_texture_terrain(terrain_obj, random_element(options['texture']))
end

function onObjectEnterScriptingZoneBua(zone,obj)
  print('onObjectEnterScriptingZoneBua ' , zone.getName(), ' ', obj.getName() )
end

function onObjectLeaveScriptingZoneBua(zone,obj)
  print('onObjectLeaveScriptingZoneBua ', zone.getName(), ' ', obj.getName())
end

function callback_bua_zone(zone, name, color)
    print('callback_bua_zone ' .. zone.getName())
end

function create_bua_zone(bua, name)
  local b = bua.getBounds()
  local size = b.size
  size.y = 4
  local zone_spawn = {
    position = bua.getPosition(),
    rotation = bua.getRotation(),
    scale = size,
    type = 'ScriptingTrigger',
        callback = 'callback_bua_zone'
  }
  local obj = spawnObject(zone_spawn)
  obj.setName(name)
  obj.setLock(true)
  return obj
end


g_building_number = 1

-- Add a building to a plot, so BUA has some buildings to show
function spawn_building(plot)
  print_info("spawn_building ")

  -- local spawn_data = get_spawn_data(model_name, pos, rotation.y, minimal_collider,
  --   false)
  -- if spawn_data == nil then
  --   -- Error already logged
  --   return nil
  -- end
  -- spawn_data['spawn'].callback_function = on_building_spawned
  -- local building = spawnObject(spawn_data['spawn'])
  -- building.setCustomObject(spawn_data['custom_obj_attrs'])
  -- building.setLock(true)
  -- building.setName("building # " .. tostring(g_building_number))
  -- building.setRotation(rotation)
  -- g_building_number = g_building_number + 1
  -- return building
end

-- Find the location of buildings for a built up area.
-- terrain_obj: Built Up Area that is to have buildings placed onto it.
-- return: Structure describing the location of the buildings.
function calc_bua_plots(terrain_obj)
  local plots = {}
  local plot_size = {x = 3, z= 2.25} -- size of land for a building
  local terrain_size = terrain_obj.getBounds().size
  -- Fake having a smaller terrain size since the values we get out of
  -- bounds are not necessarily correct
  terrain_size.x = terrain_size.x * 0.75
  terrain_size.z = terrain_size.z * 0.75

  local terrain_pos = terrain_obj.getPosition()
  local nb_cols = math.floor(terrain_size.x / plot_size.x)
  local nb_rows = math.floor(terrain_size.z / plot_size.z)
  if (nb_cols == 0) then
    plot_size.x = 0
    nb_cols = 1
  end
  if (nb_rows == 0) then
    plot_size.z = 0
    nb_rows = 1
  end
  -- more faking of terrain size
  if nb_rows > 2 then
    nb_rows = 2
  end
  if nb_cols > 2 then
    nb_cols = 2
  end
  local area = {x=plot_size.x * nb_cols, z=plot_size.z*nb_rows}
  local margin = {x=(terrain_size.x-area.x), z=(terrain_size.z-area.z)}
  local z = (-terrain_size.z/2) +  (plot_size.z/2) + ((terrain_size.z - area.z) / 2)
  for row = 1,nb_rows do
    local x = (-terrain_size.x/2) +  (plot_size.x/2) + ((terrain_size.x - area.x) / 2)
    for col = 1,nb_cols do
      local point = {x=x, y=0, z=z}
      -- in degrees
      local terrain_rotation = terrain_obj.getRotation()
      -- in radians
      terrain_rotation_y = math.rad(terrain_rotation.y)
      local new_pos = rotate_point_relative(point, terrain_pos, terrain_rotation_y)
      local rotation_y =  normalize_degrees(terrain_rotation.y + (180 * ((row+1) % 2)))
      local plot = {
        position = new_pos,
        rotation = { x=terrain_rotation.x, y=rotation_y, z=terrain_rotation.z}
      }
      table.insert(plots, plot)
      x = x + plot_size.x
    end
    z = z + plot_size.z
  end
  return plots
end

-- Add buildings to the Built Up Area (BUA) to make it look pretty.
-- terrain_obj: template of the BUA
-- terrain_rotation: float, y-axis rotation of BUA in radians
-- options: Source of data for BUA for the table type
function add_buildings(terrain_obj, terrain_rotation, options)
  print("add_buildings")
  local plots = calc_bua_plots(terrain_obj)
  for _,plot in pairs(plots) do
     plot.model_name = random_element(options['objects'])
     local building = spawn_building(plot)
  end
  print("OUT add_buildings")
end

function set_bua(terrain_obj, terrain_pos, terrain_rotation, terrain_size, table_type)
  local name = "zone bua " .. terrain_obj.getGUID()
  create_bua_zone(terrain_obj, name)
  local options = g_terrain[table_type]['bua']
  change_texture_terrain(terrain_obj, random_element(options['texture']))
  terrain_obj.setLock(true)
  add_buildings(terrain_obj, terrain_rotation, options)
end

function set_enclosure(terrain_obj, terrain_pos, terrain_rotation, terrain_size, table_type)
    local options = g_terrain[table_type]['enclosure']
    local objs_x = math.floor(terrain_size['x'])
    local margin_x = (terrain_size['x'] - objs_x) / 2
    local objs_z = math.floor(terrain_size['z'])
    local margin_z = (terrain_size['z'] - objs_z) / 2

    local plough_asset = first_value_table(options['objects'])

    for i=1,objs_x do
        for j=1,objs_z do
            local point = {
                x = margin_x + 0.5 + i - 1 - terrain_size['x'] / 2,
                y = 0,
                z = margin_z + 0.5 + j - 1 - terrain_size['z'] / 2
            }
            local new_pos = rotate_point_relative(point, terrain_pos, terrain_rotation)
            local obj = spawn_asset(plough_asset, new_pos, terrain_obj.getRotation()['y'])
            terrain_obj.addAttachment(obj)
        end
    end

    local fence_asset = first_value_table(options['outline_objects'])
    for i=1,objs_x do
        local point_up = {
            x = margin_x + 0.5 + i - 1 - terrain_size['x'] / 2,
            y = 0,
            z = terrain_size['z'] / 2 - 0.1
        }
        local new_pos_up = rotate_point_relative(point_up, terrain_pos, terrain_rotation)

        local obj_up = spawn_model(fence_asset, new_pos_up, terrain_obj.getRotation()['y'], minimal_collider, true)
        terrain_obj.addAttachment(obj_up)

        local point_down = {
            x = margin_x + 0.5 + i - 1 - terrain_size['x'] / 2,
            y = 0,
            z = - terrain_size['z'] / 2 + 0.1
        }
        local new_pos_down = rotate_point_relative(point_down, terrain_pos, terrain_rotation)
        local obj_down = spawn_model(fence_asset, new_pos_down, terrain_obj.getRotation()['y'] + 180, minimal_collider, true)
        terrain_obj.addAttachment(obj_down)
    end

    for j=1,objs_z do
        local point_left = {
            x = - terrain_size['x'] / 2 + 0.1,
            y = 0,
            z = margin_z + 0.5 + j - 1 - terrain_size['z'] / 2
        }
        local new_pos_left = rotate_point_relative(point_left, terrain_pos, terrain_rotation)
        local obj_left = spawn_model(fence_asset, new_pos_left, terrain_obj.getRotation()['y'] + 90, minimal_collider, true)
        terrain_obj.addAttachment(obj_left)

        local point_right = {
            x = terrain_size['x'] / 2 - 0.1,
            y = 0,
            z = margin_z + 0.5 + j - 1 - terrain_size['z'] / 2
        }
        local new_pos_right = rotate_point_relative(point_right, terrain_pos, terrain_rotation)
        local obj_right = spawn_model(fence_asset, new_pos_right, terrain_obj.getRotation()['y'] + 270, minimal_collider, true)
        terrain_obj.addAttachment(obj_right)
    end
    change_texture_terrain(terrain_obj, random_element(options['texture']))
end

function process_vegetation(terrain_obj, type)
    local terrain_pos = terrain_obj.getPosition()
    local terrain_rotation = normalize_angle(math.rad(terrain_obj.getRotation()['y']))
    local terrain_size = terrain_obj.getBoundsNormalized()['size']
    if str_starts_with(terrain_obj.getName(), 'terrain Forest') then
        set_forest(terrain_obj, terrain_pos, terrain_rotation, terrain_size, type)
    elseif str_starts_with(terrain_obj.getName(), 'terrain Arid') then
        set_arid(terrain_obj, terrain_pos, terrain_rotation, terrain_size, type)
    elseif str_starts_with(terrain_obj.getName(), 'terrain Oasis') then
        set_oasis(terrain_obj, terrain_pos, terrain_rotation, terrain_size, type)
    elseif str_starts_with(terrain_obj.getName(), 'terrain Plough') then
        set_plough(terrain_obj, terrain_pos, terrain_rotation, terrain_size, type)
    elseif str_starts_with(terrain_obj.getName(), 'terrain Enclosure') then
        set_enclosure(terrain_obj, terrain_pos, terrain_rotation, terrain_size, type)
    elseif str_starts_with(terrain_obj.getName(), 'terrain Marsh') then
        set_marsh(terrain_obj, terrain_pos, terrain_rotation, terrain_size, type)
    elseif str_starts_with(terrain_obj.getName(), 'terrain BUA') then
          set_bua(terrain_obj, terrain_pos, terrain_rotation, terrain_size, type)
    end
end
